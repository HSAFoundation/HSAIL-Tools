// ============================================================================
// ============================================================================
// PROPERTIES
// ============================================================================
// ============================================================================

// ============================================================================
// Instruction/operand type

BrigProp type = 
    
    none,

    b  = b(1, 8, 16, 32, 64, 128),
    s  = s(8, 16, 32, 64), 
    u  = u(8, 16, 32, 64), 
    f  = f(16, 32, 64),

    sx.32  = s(8x4, 16x2),
    sx.64  = s(8x8, 16x4, 32x2),
    sx.128 = s(8x16, 16x8, 32x4, 64x2),

    ux.32  = u(8x4, 16x2),
    ux.64  = u(8x8, 16x4, 32x2),
    ux.128 = u(8x16, 16x8, 32x4, 64x2),

    fx.32  = f(16x2),
    fx.64  = f(16x4, 32x2),
    fx.128 = f(16x8, 32x4, 64x2),

    roimg, rwimg, samp, sig32, sig64;

Alias sx = sx.(32, 64, 128);
Alias ux = ux.(32, 64, 128);
Alias fx = fx.(32, 64, 128);

Alias x    = (s, u, f)x;
Alias x.32 = (s, u, f)x.32;
Alias x.64 = (s, u, f)x.64;

Alias s8x  = s(8x4, 8x8, 8x16);
Alias s16x = s(16x2, 16x4, 16x8);
Alias s32x = s(32x2, 32x4);
Alias s64x = s(64x2);

Alias u8x  = u(8x4, 8x8, 8x16);
Alias u16x = u(16x2, 16x4, 16x8);
Alias u32x = u(32x2, 32x4);
Alias u64x = u(64x2);

Alias f16x = f(16x2, 16x4, 16x8);
Alias f32x = f(32x2, 32x4);
Alias f64x = f(64x2);

Alias opaque = roimg, rwimg, samp, sig32, sig64;

Clone stype;   ExtPropName sourceType;  // src type
Clone itype;   ExtPropName imageType;   // image type
Clone ctype;   ExtPropName coordType;   // coord type
Clone sigtype; ExtPropName signalType;  // signal type

// ============================================================================
// Segment

BrigProp segment = 
    none,
    flat,
    global,
    group,
    private,
    kernarg,
    readonly,
    spill,
    arg,
    ExtSpace0;

Alias any      = global, group, private, spill, arg, flat, kernarg, readonly;
Alias writable = global, group, private, spill, arg, flat;
Alias std      = global, group, private, spill, arg,       kernarg, readonly;
Alias gcn      = ExtSpace0;

// ============================================================================
// Special type checks

MetaProp typesize = 
    atomic, // type size must be 32 for small model and 32/64 for large model
    model,  // type size must be 32 or 64 depending on machine model
    signal, // type size must be sig32 or sig64 depending on machine model
    seg;    // type must be b32/b64 depending on _instruction_ segment

Affects type, segment;

MetaProp stypesize = model, seg;

Affects stype;

// ============================================================================
// CMP Operators

BrigProp compare = 
    eq,   ne,   lt,   le,   gt,   ge,
    equ,  neu,  ltu,  leu,  gtu,  geu,
    seq,  sne,  slt,  sle,  sgt,  sge,
    sequ, sneu, sltu, sleu, sgeu, sgtu,

    num,  snum, 
    nan,  snan;

// ============================================================================
// Packing

BrigProp pack = 
    none,
    p, s,
    pp, ps, sp, ss, 
    ppsat, pssat, spsat, sssat,
    ssat, psat;

Alias bin       = pp, ps, sp, ss, ppsat, pssat, spsat, sssat;
Alias bin.nosat = pp, ps, sp, ss;

PropAccessor packEx;

// ============================================================================
// Rounding

BrigProp round = 
    none,
    float   = (float_near_even, float_zero, float_plus_infinity, float_minus_infinity),
    int     = (integer_near_even, integer_zero, integer_plus_infinity, integer_minus_infinity, 
               integer_near_even_sat, integer_zero_sat, integer_plus_infinity_sat, integer_minus_infinity_sat);

PropAccessor roundEx;

// ============================================================================
// FTZ Modifier

BrigBitProp ftz;

PropAccessor ftzEx;

// ============================================================================
// Const Modifier

BrigBitProp const;

ExtPropName isConst;

// ============================================================================
// NoNull Modifier

BrigBitProp nonull;

ExtPropName isNoNull;

// ============================================================================
// Align Modifier

BrigProp align =
    none,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128;

Alias any  = * / none;

BrigPrefix ALIGNMENT;

// ============================================================================
// Equivalence Class

ExtProp eqclass = 0, any;

ExtPropName equivClass;

// ============================================================================
// Memory Order

BrigProp memord = 
    none,
    acq = acquire,
    rel = release,
    ar  = acquire_release,
    rlx = relaxed;

Alias any  = * / none;
Alias wait = * / (none, ar, rel);
Alias ld   = * / (none, ar, rel);
Alias st   = * / (none, ar, acq);

BrigPrefix  MEMORY_ORDER;
ExtPropName memoryOrder;

// ============================================================================
// Memory Scope

BrigProp memscp = 
    none,
    wv  = wavefront,
    wg  = workgroup,
    cmp = component,
    sys = system;

Alias any = * / none;

BrigPrefix  MEMORY_SCOPE;
ExtPropName memoryScope;

// ============================================================================
// Memory Fence

BrigProp memseg = 
    none,
    group,
    global,
    both;

Alias any = * / none;

BrigPrefix  MEMORY_FENCE;
ExtPropName segments;

// ============================================================================
// Atomic Operations

BrigProp atmop = 
    and, or, xor, 
    add, sub, 
    inc, dec, 
    min, max, 
    exch, cas,
    ld, st;

Alias generic = * / (exch, ld, st);

BrigPrefix  ATOMIC;
ExtPropName atomicOperation;

// ============================================================================
// Signal Operations

BrigProp sigop =
    inc, dec,
    add, sub, max, min,
    ld, st, and, or, xor, exch, cas,
    wait_eq, wait_ne, wait_lt, wait_gte,
    waittimeout_eq, waittimeout_ne, waittimeout_lt, waittimeout_gte;

Alias wait        = wait_eq, wait_ne, wait_lt, wait_gte;
Alias waittimeout = waittimeout_eq, waittimeout_ne, waittimeout_lt, waittimeout_gte;

BrigPrefix  SIGNAL;
ExtPropName signalOperation;

// ============================================================================
// Image Geometry

BrigProp geometry = 
    1d,  2d,  3d, 
    1db, 1da, 2da;

// ============================================================================
// Width

BrigProp width = 
    none,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256,
    512,
    1024,
    2048,
    4096,
    8192,
    16384,
    32768,
    65536,
    131072,
    262144,
    524288,
    1048576,
    2097152,
    4194304,
    8388608,
    16777216,
    33554432,
    67108864,
    134217728,
    268435456,
    536870912,
    1073741824,
    2147483648,
    wavesize,
    all;

Alias any = * / none;

// ============================================================================
// Operands 

OperandProp operand = 
    null, 
    jumptab, calltab,       // NB: no type
    arglist,                // NB: no type
    (lab, func).model,
    fbarrier.u32,
    addr.(seg,              // 1) address size must match _instruction_ segment size; 
                            // 2) if inst.segment=flat, address must be flat
                            // 3) if address includes a symbol, symbol.segment must be the same as instr.segment
          
          tseg),            // 1+2+3+4
                            // 4) opaque symbols used in address must match instruction type (rwimg, roimg, samp, sig32, sig64)
    
    (roimage, rwimage).(itype, stype),  // FIXME: should be removed as soon as image support is implemented
    sampler.samp,                       // FIXME: should be removed as soon as image support is implemented

    (imm0T2, imm0T3).u32,
    (reg, reg.v2, reg.v3, reg.v4, imm).(b1, b32, b64, u32, u64, s32, s64, p2u, dtype, stype, ctype),
    reg.(samp, sig32, sig64, model, itype);

Alias reg    = reg.dtype;
Alias reg.v2 = reg.v2.dtype;
Alias reg.v3 = reg.v3.dtype;
Alias reg.v4 = reg.v4.dtype;
Alias imm    = imm.dtype;

Alias reg.v     = reg.(v2, v3, v4);

Alias image.itype = (roimage, rwimage).itype;
Alias image.stype = (roimage, rwimage).stype;

Clone  d0, d1, s0, s1, s2, s3, s4;

Attr dtype, stype, ctype, itype, model, p2u, seg, tseg,
     b1, b32, b64, u32, u64, s32, s64, samp, sig32, sig64;

DependsOn type, stype, ctype, itype;

// ============================================================================
// Operands templates (frequently used cases)

Req d0.s1
{
    d0 = reg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req d0.s1.s2
{
    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = null;
    s4 = null;
}

Req  d0.s1.s2.s3
{
    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

// ============================================================================
// ============================================================================
// DESCRIPTION OF STANDARD HSAIL INSTRUCTIONS
// ============================================================================
// ============================================================================

// ============================================================================
// ADD, SUB

Req add
{
    type = (s, u)(32, 64), f, x;

    { type = (s, u)(32, 64) ? pack = none;      round = none;  ftz = none }
    { type = f              ? pack = none;      round = float; ftz = any  }
    { type = (s, u)x        ? pack = bin;       round = none;  ftz = none }
    { type = fx             ? pack = bin.nosat; round = float; ftz = any  }
    ;

    d0.s1.s2;
}

Inst add(Mod, arithmetic, add)
Inst sub(Mod, arithmetic, add)

// ============================================================================
// MAX, MIN

Req max
{
    type  = (s, u)(32, 64), f, x;
    ftz   = any;
    round = none;

    { type = (s, u)(32, 64) ? pack = none;      ftz = none }
    { type = f              ? pack = none;      ftz = any  }
    { type = (s, u)x        ? pack = bin.nosat; ftz = none }
    { type = fx             ? pack = bin.nosat; ftz = any  }
    ;

    d0.s1.s2;
}

Inst max(Mod, arithmetic, max)
Inst min(Mod, arithmetic, max)

// ============================================================================
// MUL

Req mul
{
    type = (s, u)(32, 64), f, x;
    ftz  = any;

    { type = (s, u)(32, 64); ? pack = none;      round = none;  ftz = none }
    { type = f               ? pack = none;      round = float; ftz = any  }
    { type = (s, u)x;        ? pack = bin;       round = none;  ftz = none }
    { type = fx              ? pack = bin.nosat; round = float; ftz = any  }
    ;

    d0.s1.s2;
}

Inst mul(Mod, arithmetic, mul)

// ============================================================================
// MULHI

Req mulhi
{
    type  = (s, u)(32, 64, x);
    round = none;  
    ftz   = none;

    { type = (s, u)(32, 64); ? pack = none;      }
    { type = (s, u)x;        ? pack = bin.nosat; }
    ;

    d0.s1.s2;
}

Inst mulhi(Mod, arithmetic, mulhi)

// ============================================================================
// DIV

Req div
{
    type    = (s, u)(32, 64), f, fx;

    { type = (s, u)(32, 64) ? pack = none;      round = none;  ftz = none }
    { type = f              ? pack = none;      round = float; ftz = any  }
    { type = fx             ? pack = bin.nosat; round = float; ftz = any  }
    ;

    d0.s1.s2;
}

Inst div(Mod, arithmetic, div)

// ============================================================================
// REM, CARRY, BORROW

Req rem
{
    type    = (s, u)(32, 64);

    d0.s1.s2;
}

Inst rem   (Basic, arithmetic, rem)
Inst carry (Basic, arithmetic, rem)
Inst borrow(Basic, arithmetic, rem)

// ============================================================================
// NEG, ABS

Req neg
{
    type  = s(32, 64, x), f, fx;
    round = none;  
    ftz   = none;

    { type = s(32, 64), f ? pack = none }
    { type = (s, f)x      ? pack = s, p }
    ;

    d0.s1;
}

Inst neg(Mod, arithmetic, neg)
Inst abs(Mod, arithmetic, neg)

// ============================================================================
// COPYSIGN

Req copysign
{
    type  = f, fx;
    round = none;  
    ftz   = none;

    { type = f  ? pack = none      }
    { type = fx ? pack = bin.nosat }
    ;

    d0.s1.s2;
}

Inst copysign(Mod, arithmetic, copysign)

// ============================================================================
// FRACT

Req fract
{
    type  = f, fx;
    round = none; 
    ftz   = any;

    { type = f  ? pack = none }
    { type = fx ? pack = p, s }
    ;
    
    d0.s1;
}

Inst fract(Mod, arithmetic, fract)

// ============================================================================
// SQRT

Req sqrt
{
    type  = f, fx;
    round = float; 
    ftz   = any;

    { type = f  ? pack = none }
    { type = fx ? pack = p, s }
    ;
    
    d0.s1;
}

Inst sqrt(Mod, arithmetic, sqrt)

// ============================================================================
// CEIL, FLOOR, RINT, TRUNC 

Req ceil
{
    type  = f, fx;
    round = none; 
    ftz   = any;

    { type = f  ? pack = none }
    { type = fx ? pack = p, s }
    ;
    
    d0.s1;
}

Inst ceil (Mod, arithmetic, ceil)
Inst floor(Mod, arithmetic, ceil)
Inst rint (Mod, arithmetic, ceil)
Inst trunc(Mod, arithmetic, ceil)

// ============================================================================
// MUL24, MUL24HI

Req mul24
{ 
    type     = (s, u)32;

    d0.s1.s2;
}

Inst mul24  (Basic, arithmetic, mul24)
Inst mul24hi(Basic, arithmetic, mul24)

// ============================================================================
// MAD24, MAD24HI

Req mad24
{ 
    type     = (s, u)32;

    d0.s1.s2.s3;
}

Inst mad24  (Basic, arithmetic, mad24)
Inst mad24hi(Basic, arithmetic, mad24)

// ============================================================================
// MAD

Req mad
{
    type    = (s, u)(32, 64);

    d0.s1.s2.s3;
}

Inst mad(Basic, arithmetic, mad)

// ============================================================================
// FMA

Req fma
{
    type  = f;
    pack  = none;
    round = float;
    ftz   = any;

    d0.s1.s2.s3;
}

Inst fma(Mod, arithmetic, fma)

// ============================================================================
// SHL, SHR

Req shift
{ 
    type    = (s, u)(32, 64, x);

    d0 = reg;
    s1 = (reg, imm);
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst shl(Basic, arithmetic, shift)
Inst shr(Basic, arithmetic, shift)

// ============================================================================
// AND, OR, XOR

Req and
{ 
    type   = b(1, 32, 64);

    d0.s1.s2;
}

Inst and(Basic, arithmetic, and)
Inst or (Basic, arithmetic, and)
Inst xor(Basic, arithmetic, and)

// ============================================================================
// NOT

Req not
{ 
    type   = b(1, 32, 64);

    d0.s1;
}

Inst not(Basic, arithmetic, not)

// ============================================================================
// POPCOUNT

Req popcount
{ 
    type   = u32;
    stype  = b(32, 64);

    d0 = reg;
    s1 = (reg, imm).stype; 
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst popcount(Source.Type, arithmetic, popcount)

// ============================================================================
// BITMASK

Req bitmask
{ 
    type    = b(32, 64);

    d0 = reg;
    s1 = (reg, imm).u32;
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst bitmask(Basic, arithmetic, bitmask)

// ============================================================================
// BITSELECT

Req bitselect
{ 
    type    = b(32, 64);

    d0.s1.s2.s3;
}

Inst bitselect(Basic, arithmetic, bitselect)

// ============================================================================
// BITREV

Req bitrev
{ 
    type    = b(32, 64);

    d0.s1;
}

Inst bitrev(Basic, arithmetic, bitrev)

// ============================================================================
// BITEXTRACT

Req bitextract
{ 
    type    = (s, u)(32, 64);

    d0 = reg;       
    s1 = (reg, imm); 
    s2 = (reg, imm).u32;
    s3 = (reg, imm).u32;
    s4 = null;
}

Inst bitextract(Basic, arithmetic, bitextract)

// ============================================================================
// BITINSERT

Req bitinsert
{ 
    type    = (s, u)(32, 64);

    d0 = reg;       
    s1 = (reg, imm); 
    s2 = (reg, imm);
    s3 = (reg, imm).u32;
    s4 = (reg, imm).u32;
}

Inst bitinsert(Basic, arithmetic, bitinsert)

// ============================================================================
// FIRSTBIT, LASTBIT

Req firstbit
{ 
    type  = u32;
    stype = (s, u)(32, 64);
       
    d0 = reg;
    s1 = (reg, imm).stype; 
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst firstbit(Source.Type, arithmetic, firstbit)
Inst lastbit (Source.Type, arithmetic, firstbit)

// ============================================================================
// COMBINE

Req combine
{ 
    type    = b(64, 128);
    stype   = b(32, 64);

    { type = b64;  stype = b32 ? s1 = reg.v2.stype }
    { type = b128; stype = b64 ? s1 = reg.v2.stype }
    { type = b128; stype = b32 ? s1 = reg.v4.stype }
    ;

    d0 = reg;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst combine(Source.Type, move, combine)

// ============================================================================
// EXPAND

Req expand
{ 
    type    = b(32, 64);
    stype   = b(64, 128);

    { type = b32; stype = b64  ? d0 = reg.v2 }
    { type = b32; stype = b128 ? d0 = reg.v4 }
    { type = b64; stype = b128 ? d0 = reg.v2 }
    ;

    s1 = (reg, imm).stype;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst expand(Source.Type, move, expand)

// ============================================================================
// MOV

Req mov
{ 
    type    = b(1, 32, 64, 128), (s, u)(32, 64), f, opaque;

    d0 = reg;
    s1 = reg, imm;
    s2 = null;       
    s3 = null;       
    s4 = null;

    { type = b(1, 32, 64, 128), (s, u)(32, 64), f ? s1 = reg, imm }
    { type = opaque                               ? s1 = reg      }
    ;
}

Inst mov(Basic, move, mov)

// ============================================================================
// LDA

Req lda
{ 
    type = u(32, 64);
    segment = any;

    typesize = seg;

    d0 = reg;       
    s1 = addr.seg;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst lda(Addr, arithmetic, lda)

// ============================================================================
// LDC

Req ldc
{ 
    type    = u(32, 64);

    typesize = model;

    d0 = reg;
    s1 = (lab, func).model;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst ldc(Basic, arithmetic, ldc)

// ============================================================================
// SHUFFLE

Req shuffle
{ 
    type    = x.(32, 64);

    d0 = reg;       
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = imm;
    s4 = null;

    { type = x.32; ? s3 = imm.b32 }
    { type = x.64; ? s3 = imm.b64 }
    ;
}

Inst shuffle(Basic, arithmetic, shuffle)

// ============================================================================
// UNPACKLO, UNPACKHI

Req unpackx
{ 
    type    = x.(32, 64);

    d0.s1.s2;
}

Inst unpacklo(Basic, arithmetic, unpackx)
Inst unpackhi(Basic, arithmetic, unpackx)

// ============================================================================
// PACK

Req pack
{ 
    type  = x;
    stype = (s, u)(32, 64), f;

    { type = s(8, 16, 32)x ? stype = s32, s64 }
    { type = s64x          ? stype = s64      }
    { type = u(8, 16, 32)x ? stype = u32, u64 }
    { type = u64x          ? stype = u64      }
    { type = f16x          ? stype = f16      }
    { type = f32x          ? stype = f32      }
    { type = f64x          ? stype = f64      }
    ;

    d0 = reg;       
    s1 = reg, imm;
    s2 = (reg, imm).stype;
    s3 = (reg, imm).u32;
    s4 = null;
}

Inst pack(Source.Type, arithmetic, pack)

// ============================================================================
// UNPACK

//F s2 must be in the range [0, number of elements in the packed source type - 1]. 

Req unpack
{ 
    type  = (s, u)(32, 64), f;
    stype = x;

    { type = s32 ? stype = s(8, 16, 32)x     }
    { type = s64 ? stype = s(8, 16, 32, 64)x }
    { type = u32 ? stype = u(8, 16, 32)x     }
    { type = u64 ? stype = u(8, 16, 32, 64)x }
    { type = f16 ? stype = f16x              }
    { type = f32 ? stype = f32x              }
    { type = f64 ? stype = f64x              }
    ;

    d0 = reg;       
    s1 = (reg, imm).stype;
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst unpack(Source.Type, arithmetic, unpack)

// ============================================================================
// CMOV

Req cmov
{ 
    type    = b(1, 32, 64), x;

    d0 = reg;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;

    { type = b(1, 32, 64) ? s1 = (reg, imm).b1  }
    { type = x            ? s1 = (reg, imm).p2u } // convert packed type tAxB to unsigned uAxB. See convPackedType2U
    ;
}

Inst cmov(Basic, arithmetic, cmov)

// ============================================================================
// CLASS

Req class
{
    type  = b1;
    stype = f;
       
    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst class(Source.Type, arithmetic, class)

// ============================================================================
// NSIN, NCOS, NLOG2, NEXP2, NSQRT, NRSQRT, NRCP, NFMA

Req trig32
{
    type     = f32;

    d0.s1;
}

Req trig
{
    type     = f;

    d0.s1;
}

Req nfma
{
    type     = f;

    d0.s1.s2.s3;
}

Inst nsin  (Basic, arithmetic, trig32)
Inst ncos  (Basic, arithmetic, trig32)
Inst nlog2 (Basic, arithmetic, trig32)
Inst nexp2 (Basic, arithmetic, trig32)

Inst nsqrt (Basic, arithmetic, trig)
Inst nrsqrt(Basic, arithmetic, trig)
Inst nrcp  (Basic, arithmetic, trig)

Inst nfma  (Basic, arithmetic, nfma)

// ============================================================================
// BITALIGN, BYTEALIGN

Req align
{ 
    type    = b32;

    d0.s1.s2.s3;
} 

Inst bitalign (Basic, arithmetic, align)
Inst bytealign(Basic, arithmetic, align)

// ============================================================================
// LERP

Req lerp
{ 
    type    = u8x4;

    d0.s1.s2.s3;
} 

Inst lerp(Basic, arithmetic, lerp)

// ============================================================================
// SAD

Req sad
{ 
    type  = u32;
    stype = u32, u8x4, u16x2;

    d0 = reg;
    s1 = (reg, imm).stype; 
    s2 = (reg, imm).stype; 
    s3 = (reg, imm).u32;
    s4 = null;
} 

Inst sad(Source.Type, arithmetic, sad)

// ============================================================================
// SADHI

Req sadhi
{ 
    type  = u16x2;
    stype = u8x4;

    d0 = reg;
    s1 = (reg, imm).stype; 
    s2 = (reg, imm).stype; 
    s3 = reg, imm;
    s4 = null;
} 

Inst sadhi(Source.Type, arithmetic, sadhi)

// ============================================================================
// PACKCVT

Req packcvt
{ 
    type  = u8x4;
    stype = f32;

    d0 = reg;
    s1 = (reg, imm).stype; 
    s2 = (reg, imm).stype; 
    s3 = (reg, imm).stype; 
    s4 = (reg, imm).stype; 
} 

Inst packcvt(Source.Type, arithmetic, packcvt)

// ============================================================================
// UNPACKCVT

Req unpackcvt
{ 
    type  = f32;
    stype = u8x4;

    d0 = reg;
    s1 = (reg, imm).stype; 
    s2 = imm0T3.u32;
    s3 = null;
    s4 = null;
} 

Inst unpackcvt(Source.Type, arithmetic, unpackcvt)

// ============================================================================
// SEGMENTP

Req segmentp
{ 
    type    = b1;
    stype   = u(32, 64);
    segment = std;
    nonull  = any;

    stypesize = model;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst segmentp(Seg.Cvt, arithmetic, segmentp)

// ============================================================================
// FTOS, STOF

Req f2s
{ 
    type    = u(32, 64);
    stype   = u(32, 64);
    segment = std;
    nonull  = any;

    typesize  = seg;
    stypesize = model;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Req s2f
{ 
    type    = u(32, 64);
    stype   = u(32, 64);
    segment = std;
    nonull  = any;

    typesize  = model;
    stypesize = seg;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst ftos(Seg.Cvt, arithmetic, f2s)
Inst stof(Seg.Cvt, arithmetic, s2f)

// ============================================================================
// CMP

Req cmp
{ 
    type  = b1,    (s, u)(32, 64), f, ux;
    stype = b1, (b, s, u)(32, 64), f, x;
    round = none; 

    { stype = b1, (b, s, u)(32, 64), f ? type = b1, (s, u)(32, 64), f }
    { stype = (s, u)8x4                ? type = u8x4                  }
    { stype = (s, u)8x8                ? type = u8x8                  }
    { stype = (s, u)8x16               ? type = u8x16                 }
    { stype = (s, u, f)16x2            ? type = u16x2                 }
    { stype = (s, u, f)16x4            ? type = u16x4                 }
    { stype = (s, u, f)16x8            ? type = u16x8                 }
    { stype = (s, u, f)32x2            ? type = u32x2                 }
    { stype = (s, u, f)32x4            ? type = u32x4                 }
    { stype = (s, u, f)64x2            ? type = u64x2                 }
    ;

    { stype = b(1, 32, 64)   ? ftz = none; pack = none; compare = eq, ne                 }
    { stype = (s, u)(32, 64) ? ftz = none; pack = none; compare = eq, ne, lt, le, gt, ge }
    { stype = f              ? ftz = any;  pack = none; compare = *                      }
    { stype = (s, u)x        ? ftz = none; pack = pp;   compare = eq, ne, lt, le, gt, ge }
    { stype = fx             ? ftz = any;  pack = pp;   compare = *                      }
    ;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).stype;
    s3 = null;
    s4 = null;
}

Inst cmp(Cmp, arithmetic, cmp)

// ============================================================================
// CVT

Req cvt
{ 
    type  = b1, s, u, f;
    stype = b1, s, u, f;

    { type = b1       ? stype = s, u, f                      }
    { type = (s, u)8  ? stype = b1, (s, u)(   16, 32, 64), f }
    { type = (s, u)16 ? stype = b1, (s, u)(8,     32, 64), f }
    { type = (s, u)32 ? stype = b1, (s, u)(8, 16,     64), f }
    { type = (s, u)64 ? stype = b1, (s, u)(8, 16, 32    ), f }
    { type = f16      ? stype = b1, s, u, f                  }        //{ type = f16      ? stype = * / f16      } //F Not clear if this should be allowed
    { type = f32      ? stype = b1, s, u, f                  }        //{ type = f32      ? stype = * / f32      }
    { type = f64      ? stype = b1, s, u, f                  }        //{ type = f64      ? stype = * / f64      }
    ;

    { stype = b1, s, u; type = b1, s, u  ? round = none;  ftz = none }
    { stype = b1;       type = f         ? round = none;  ftz = none }
    { stype = s, u;     type = f         ? round = float; ftz = none }
    { stype = f;        type = b1        ? round = none;  ftz = any  }
    { stype = f;        type = s, u      ? round = int;   ftz = any  }
    { stype = f32;      type = f16       ? round = float; ftz = any  }
    { stype = f64;      type = f(16, 32) ? round = float; ftz = any  }
    { stype = f;        type = f         ? round = none;  ftz = any  } // This case must go last!
    ;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;       
    s3 = null;       
    s4 = null;
}

Inst cvt(Cvt, arithmetic, cvt)

// ============================================================================
// LD

Req ld
{ 
    type    = u, s, f, b128, opaque;
    segment = any;
    align   = any;
    const   = any;
    eqclass = any;
    width   = any;
      
    { type = u, s, f      ? d0 = (reg, reg.v) }
    { type = b128, opaque ? d0 = reg          }
    ;

    { segment = global, readonly, kernarg, flat ? const = any  }
    { segment = group, private, spill, arg      ? const = none }
    ;

    s1 = addr.tseg;
    s2 = null;
    s3 = null;
    s4 = null;
} 

Inst ld(Mem, memory, ld)

// ============================================================================
// ST

Req st
{ 
    type    = u, s, f, b128, opaque;
    segment = writable;
    align   = any;
    const   = none;
    eqclass = any;
    width   = none;

    { type = u, s, f      ? s0 = (reg, reg.v, imm) }
    { type = b128, opaque ? s0 = reg               }
    ;

    s1 = addr.tseg;
    s2 = null;
    s3 = null;
    s4 = null;
} 

Inst st(Mem, memory, st)

// ============================================================================
// ATOMIC

Req atomic
{ 
    type    = (b, s, u)(32, 64);
    atmop   = generic, exch, ld;
    segment = global, group, flat;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = reg, imm }
    { atmop = and, or, xor, exch ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = inc, dec           ? type = (u   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = ld                 ? type = (b   )(32, 64); memord = ld;  s2 = null;     s3 = null     }
    ;

    { segment = global, flat ? memscp = any    }
    { segment = group        ? memscp = wv, wg }
    ;

    d0 = reg;
    s1 = addr.seg;
    s4 = null;
}

Inst atomic(Atomic, atomic.memory, atomic)

// ============================================================================
// ATOMICNORET

Req atomic.noret
{ 
    type    = (b, s, u)(32, 64);
    atmop   = generic, st;
    segment = global, group, flat;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord  = any; s2 = reg, imm }
    { atmop = and, or, xor       ? type = (b   )(32, 64); memord  = any; s2 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord  = any; s2 = null     }
    { atmop = inc, dec           ? type = (u   )(32, 64); memord  = any; s2 = null     }
    { atmop = st                 ? type = (b   )(32, 64); memord  = st;  s2 = null     }
    ;

    { segment = global, flat ? memscp = any    }
    { segment = group        ? memscp = wv, wg }
    ;

    s0 = addr.seg;
    s1 = reg, imm;
    s3 = null;
    s4 = null;
}

Inst atomicnoret(Atomic, atomic.memory, atomic.noret)

// ============================================================================
// Signal Operations 

Req signal
{
    type    = (b, s, u)(32, 64);
    sigtype = sig32, sig64;
    memord  = any;

    typesize  = model;

    { type = (b, s, u)32 ? sigtype = sig32; s1 = reg.sig32 }
    { type = (b, s, u)64 ? sigtype = sig64; s1 = reg.sig64 }
    ; 

    { sigop = ld                 ? type = (b   )(32, 64); memord = ld;   s2 = null;     s3 = null           }
    { sigop = and, or, xor, exch ? type = (b   )(32, 64); memord = any;  s2 = reg, imm; s3 = null           }
    { sigop = cas                ? type = (b   )(32, 64); memord = any;  s2 = reg, imm; s3 = reg, imm       }
    { sigop = add, sub, min, max ? type = (s, u)(32, 64); memord = any;  s2 = reg, imm; s3 = null           }
    { sigop = inc, dec           ? type = (u   )(32, 64); memord = any;  s2 = reg, imm; s3 = null           }
    { sigop = wait               ? type = (s   )(32, 64); memord = wait; s2 = reg, imm; s3 = null           }
    { sigop = waittimeout        ? type = (s   )(32, 64); memord = wait; s2 = reg, imm; s3 = (reg, imm).u64 }
    ;

    d0 = reg;
    s4 = null;
}

Req signal.noret
{
    type    = (b, s, u)(32, 64);
    sigtype = sig32, sig64;
    memord  = any;

    typesize  = model;

    { type = (b, s, u)32 ? sigtype = sig32; s0 = reg.sig32 }
    { type = (b, s, u)64 ? sigtype = sig64; s0 = reg.sig64 }
    ; 

    { sigop = st                 ? type = (b   )(32, 64); memord = st;   s2 = null     }
    { sigop = and, or, xor       ? type = (b   )(32, 64); memord = any;  s2 = null     }
    { sigop = cas                ? type = (b   )(32, 64); memord = any;  s2 = reg, imm }
    { sigop = add, sub, min, max ? type = (s, u)(32, 64); memord = any;  s2 = null     }
    { sigop = inc, dec           ? type = (u   )(32, 64); memord = any;  s2 = null     }
    ;

    s1 = reg, imm;
    s3 = null;
    s4 = null;
}

Inst signal     (Signal, sync, signal)
Inst signalnoret(Signal, sync, signal.noret)

// ============================================================================
// RD_IMAGE

Req rdimage
{ 
    type     = (s, u, f)32;
    itype    = roimg, rwimg;
    ctype    = (s, f)32;
    geometry = 1d, 2d, 3d, 1da, 2da;
    eqclass  = any;

    d0 = reg.v4;
    s1 = (reg, image).itype;
    s2 = (reg, sampler).samp;
    s4 = null;

    { geometry = 1d      ? s3 = reg.ctype    }
    { geometry = 2d, 1da ? s3 = reg.v2.ctype }
    { geometry = 3d, 2da ? s3 = reg.v3.ctype }
    ;      
}

Inst rdimage(Image, image, rdimage)

// ============================================================================
// LDIMAGE, STIMAGE

Req ld.st.image
{ 
    type     = (s, u, f)32;
    ctype    = u32;
    geometry = 1d, 2d, 3d, 1db, 1da, 2da;
    eqclass  = any;

    { geometry = 1d, 1db ? s2 = reg.ctype    }
    { geometry = 2d, 1da ? s2 = reg.v2.ctype }
    { geometry = 3d, 2da ? s2 = reg.v3.ctype }
    ;      
}

Req ld.image
{ 
    ld.st.image;
    itype = roimg, rwimg;

    d0 = reg.v4;
    s1 = (reg, image).itype;
    s3 = null;
    s4 = null;
}

Req st.image
{ 
    ld.st.image;
    itype = rwimg;

    s0 = reg.v4;
    s1 = (reg, image).itype;
    s3 = null;
    s4 = null;
}

Inst ldimage(Image, image, ld.image)
Inst stimage(Image, image, st.image)

// ============================================================================
// ATOMICIMAGE

Req atomic.image
{ 
    type     = (b, s, u)(32, 64);
    itype    = rwimg;
    ctype    = u32;
    geometry = 1d, 2d, 3d, 1db, 1da, 2da;
    atmop    = generic, exch;
    eqclass  = any;

    typesize = atomic;

    { atmop = cas                ? type = b(32, 64);      s4 = reg, imm }
    { atmop = and, or, xor, exch ? type = b(32, 64);      s4 = null     }
    { atmop = inc, dec           ? type = u(32, 64);      s4 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); s4 = null     }
    ;

    d0 = reg;
    s1 = (reg, image).itype;
    s3 = reg, imm;

    { geometry = 1d, 1db ? s2 = reg.ctype    }
    { geometry = 2d, 1da ? s2 = reg.v2.ctype }
    { geometry = 3d, 2da ? s2 = reg.v3.ctype }
    ;
}

Inst atomicimage(Atomic.Image, atomic.image, atomic.image)

// ============================================================================
// ATOMIC_NO_RET_IMAGE

Req atomic.noret.image
{ 
    type     = (b, s, u)(32, 64);
    itype    = rwimg;
    ctype    = u32;
    geometry = 1d, 2d, 3d, 1db, 1da, 2da;
    atmop    = generic;
    eqclass  = any;

    typesize = atomic;

    { atmop = cas                ? type = b(32, 64);      s3 = reg, imm }
    { atmop = and, or, xor       ? type = b(32, 64);      s3 = null     }
    { atmop = inc, dec           ? type = u(32, 64);      s3 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); s3 = null     }
    ;

    s0 = (reg, image).itype;
    s2 = reg, imm;
    s4 = null;

    { geometry = 1d, 1db ? s1 = reg.ctype    }
    { geometry = 2d, 1da ? s1 = reg.v2.ctype }
    { geometry = 3d, 2da ? s1 = reg.v3.ctype }
    ;
}

Inst atomicimagenoret(Atomic.Image, atomic.image, atomic.noret.image)

// ============================================================================
// QUERY

Req queryimage
{ 
    type = u32;
    stype = roimg, rwimg;
       
    d0 = reg;
    s1 = (reg, image).stype;
    s2 = null;
    s3 = null;    
    s4 = null;
}

Req querysampler
{ 
    type = u32;
    stype = samp;
       
    d0 = reg;
    s1 = (reg, sampler).samp;
    s2 = null;
    s3 = null;    
    s4 = null;
}

Req querysamplerboundary
{ 
    type = u32;
    stype = samp;
       
    d0 = reg;
    s1 = (reg, sampler).samp;
    s2 = imm.u32;
    s3 = null;    
    s4 = null;
}

Inst queryimagewidth     (Source.Type, image, queryimage)
Inst queryimageheight    (Source.Type, image, queryimage)
Inst queryimagedepth     (Source.Type, image, queryimage)
Inst queryimagearray     (Source.Type, image, queryimage)
Inst queryimageorder     (Source.Type, image, queryimage)
Inst queryimageformat    (Source.Type, image, queryimage)
Inst querysamplercoord   (Source.Type, image, querysampler)
Inst querysamplerfilter  (Source.Type, image, querysampler) 
Inst querysamplerboundary(Source.Type, image, querysamplerboundary) 

// ============================================================================
// CBR

Req cbr
{ 
    type     = none;
  //width    = any;     // Moved below after all other checks are complete.
                        // This is necessary to improve diagnostics because 
                        // default 'width' value is assigned together
                        // with 's0' operand. See Brigantine::setOperand
    s0 = reg.b1;
    s1 = (reg, lab).model;
    s2 = null, jumptab;
    s3 = null;
    s4 = null;

    { s1 = reg.model ? s2 = null, jumptab }
    { s1 = lab.model ? s2 = null          }
    ;

    width = any;
}

Inst cbr(Br, branch, cbr)

// ============================================================================
// BRN

Req brn
{ 
    type     = none;
  //width    = any;     // Checked below after all other checks are complete.
                        // This is necessary to improve diagnostics because 
                        // default 'width' value is assigned together
                        // with 's0' operand. See Brigantine::setOperand

    s0 = (reg, lab).model;
    s1 = null, jumptab;
    s2 = null;
    s3 = null;
    s4 = null;

    { s0 = reg.model ? width = any; s1 = null, jumptab }
    { s0 = lab.model ? width = all; s1 = null          }
    ;
}

Inst brn(Br, branch, brn)

// ============================================================================
// BARRIER

Req barrier
{ 
    type   = none;
    width  = any;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst barrier(Br, sync, barrier)

// ============================================================================
// WAVEBARRIER

Req wavebarrier
{ 
    type   = none;
    width  = wavesize;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst wavebarrier(Br, sync, wavebarrier)

// ============================================================================
// FBAR*

Req fbar.none
{ 
    type   = none;

    s0 = (reg, fbarrier).u32;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req fbar.width
{ 
    type   = none;
    width  = any;

    s0 = (reg, fbarrier).u32;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req ldf
{ 
    type    = u32;

    s0 = reg;
    s1 = fbarrier.u32;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst initfbar   (Basic, sync, fbar.none)
Inst releasefbar(Basic, sync, fbar.none) 
Inst joinfbar   (Br,    sync, fbar.width)
Inst leavefbar  (Br,    sync, fbar.width)
Inst waitfbar   (Br,    sync, fbar.width)
Inst arrivefbar (Br,    sync, fbar.width)
Inst ldf        (Basic, sync, ldf)

// ============================================================================
// MEMFENCE

Req memfence
{ 
    type   = none;
    memord = acq, rel, ar;
    memscp = any;
    memseg = any;

    { memseg = global, both ? memscp = any    }
    { memseg = group        ? memscp = wv, wg }
    ;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst memfence(Mem.Fence, sync, memfence)

// ============================================================================
// ACTIVELANEMASK

Req activelanemask
{ 
    type  = b64;
    stype = b1;
    width = any;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst activelanemask(Lane, sync, activelanemask)

// ============================================================================
// ACTIVELANECOUNT

Req activelanecount
{ 
    type  = u32;
    stype = b1;
    width = any;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst activelanecount(Lane, sync, activelanecount)

// ============================================================================
// ACTIVELANEID

Req activelaneid
{ 
    type  = u32;
    stype = none;
    width = any;

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst activelaneid(Lane, sync, activelaneid)

// ============================================================================
// ACTIVELANESHUFFLE

Req activelaneshuffle
{ 
    type  = b(1, 32, 64, 128);
    stype = none;
    width = any;

    d0 =  reg;
    s1 =  reg, imm;
    s2 = (reg, imm).u32;
    s3 =  reg, imm;
    s4 = (reg, imm).b1;
}

Inst activelaneshuffle(Lane, sync, activelaneshuffle)

// ============================================================================
// CALL

Req call
{ 
    type     = none;
  //width    = any;     // Checked below after all other checks are complete.
                        // This is necessary to improve diagnostics because 
                        // default 'width' value is assigned together
                        // with 's0' operand. See Brigantine::setOperand

    s0 = arglist;
    s1 = (reg, func).model;
    s2 = arglist;
    s3 = null, calltab;
    s4 = null;

    { s1 = reg.model  ? width = any; s3 = null, calltab }
    { s1 = func.model ? width = all; s3 = null          }
    ;
}

Inst call(Br, branch, call)

// ============================================================================
// RET

Req ret
{ 
    type    = none;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst ret(Basic, branch, ret)

// ============================================================================
// ALLOCA

Req alloca
{ 
    type    = u32;
    segment = private;
    align   = any;
    const   = none;
    eqclass = 0;
    width   = none;

    s0 = reg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst alloca(Mem, misc, alloca)

// ============================================================================
// WORKITEMID, etc

Req spec.reg
{ 
    type    = u32;

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req spec.reg.dim
{ 
    type    = u32;

    d0 = reg;
    s1 = imm0T2.u32;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req spec.except
{ 
    type    = u32;

    s0 = imm;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req spec.clock
{ 
    type    = u64;

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req packet
{ 
    type = sig32, sig64;

    typesize = signal;

    s0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req nop
{ 
    type    = none;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst cuid             (Basic, misc, spec.reg)
Inst dim              (Basic, misc, spec.reg)
Inst getdetectexcept  (Basic, misc, spec.reg)
Inst laneid           (Basic, misc, spec.reg)
Inst maxcuid          (Basic, misc, spec.reg)
Inst maxwaveid        (Basic, misc, spec.reg)
Inst queueid          (Basic, misc, spec.reg)
Inst waveid           (Basic, misc, spec.reg)
Inst workitemflatabsid(Basic, misc, spec.reg) 
Inst workitemflatid   (Basic, misc, spec.reg)

Inst currentworkgroupsize(Basic, misc, spec.reg.dim) 
Inst gridgroups          (Basic, misc, spec.reg.dim)
Inst gridsize            (Basic, misc, spec.reg.dim)
Inst workgroupid         (Basic, misc, spec.reg.dim)
Inst workgroupsize       (Basic, misc, spec.reg.dim)
Inst workitemabsid       (Basic, misc, spec.reg.dim)
Inst workitemid          (Basic, misc, spec.reg.dim)

Inst cleardetectexcept(Basic, misc, spec.except)
Inst setdetectexcept  (Basic, misc, spec.except)

Inst clock   (Basic, misc, spec.clock)
Inst packetid(Basic, misc, spec.clock)

Inst packetcompletionsig(Basic, misc, packet)

Inst nop(Basic, misc, nop)

// ============================================================================
// QUEUEPTR, NULLPTR

Req gptr
{ 
    type    = u(32, 64);
    segment = flat, global;

    typesize = seg;

    s0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req nullptr
{ 
    type    = u(32, 64);
    segment = any;

    typesize = seg;

    s0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst queueptr       (Seg, misc, gptr)
Inst servicequeueptr(Seg, misc, gptr)
Inst nullptr        (Seg, misc, nullptr)

// ============================================================================
// User Mode Queue Operations 

Req addq.wrt
{ 
    type    = u64;
    segment = flat, global;
    memord  = any;

    d0 = reg;
    s1 = addr.seg;
    s2 = reg, imm;
    s3 = null;
    s4 = null;
}

Req casq.wrt
{ 
    type    = u64;
    segment = flat, global;
    memord  = any;

    d0 = reg;
    s1 = addr.seg;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req ldq
{ 
    type    = u64;
    segment = flat, global;
    memord  = rlx, acq;

    d0 = reg;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req stq.wrt
{ 
    type    = u64;
    segment = flat, global;
    memord  = rlx, acq;

    s0 = addr.seg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst addqueuewriteindex(Queue, misc, addq.wrt)
Inst casqueuewriteindex(Queue, misc, casq.wrt)
Inst ldqueuereadindex  (Queue, misc, ldq     )
Inst ldqueuewriteindex (Queue, misc, ldq     )
Inst stqueuewriteindex (Queue, misc, stq.wrt )

// ============================================================================

Req debugtrap
{ 
    type    = u32;

    s0 = reg, imm;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst debugtrap(Basic, misc, debugtrap)

// ============================================================================

Req codeblockend
{
    type = none;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst codeblockend(Basic, misc, codeblockend)

// ============================================================================
// ============================================================================
// DESCRIPTION OF GCN INSTRUCTIONS
// ============================================================================
// ============================================================================

// ============================================================================
// GCN MADU, MADS

Req gcn_madu
{ 
    type    = b32;

    d0 = reg.u64;
    s1 = (reg, imm).u32;
    s2 = (reg, imm).u32;
    s3 = (reg, imm).u64;
    s4 = null;
}

Req gcn_mads
{ 
    type = b32;

    d0 = reg.s64;
    s1 = (reg, imm).s32;
    s2 = (reg, imm).s32;
    s3 = (reg, imm).s64;
    s4 = null;
}

Inst gcnmadu(Basic, gcn.arithmetic, gcn_madu)
Inst gcnmads(Basic, gcn.arithmetic, gcn_mads)

// ============================================================================
// GCN MIN, MAX, MIN3, MED3, MAX3, BFM

Req gcn_min_max
{
    type = (s, u)32, f(32, 64);
    d0.s1.s2;
}

Req gcn_min_max_med3
{ 
    type    = (s, u, f)32;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req gcn_bfm
{ 
    type    = b32;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = null;
    s4 = null;
}

Inst gcnmin(Basic, gcn.arithmetic, gcn_min_max)
Inst gcnmax(Basic, gcn.arithmetic, gcn_min_max)
Inst gcnmin3(Basic, gcn.arithmetic, gcn_min_max_med3)
Inst gcnmed3(Basic, gcn.arithmetic, gcn_min_max_med3)
Inst gcnmax3(Basic, gcn.arithmetic, gcn_min_max_med3)
Inst gcnbfm (Basic, gcn.arithmetic, gcn_bfm)

// ============================================================================
// GCN FLDEXP, FREXP_EXP, FREXP_MANT, FREXP_PREOP

Req gcn_fldexp
{ 
    type    = f(32, 64);

    d0 = reg;
    s1 = reg, imm;
    s2 = (reg, imm).s32;
    s3 = null;
    s4 = null;
}

Req gcn_frexp_exp
{ 
    type    = f(32, 64);

    d0 = reg.s32;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req gcn_frexp_mant
{ 
    type    = f(32, 64);

    d0 = reg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req gcn_trig_preop
{ 
    type    = f64;

    d0 = reg;
    s1 = reg, imm;
    s2 = imm.u32;
    s3 = null;
    s4 = null;
}

Inst gcnfldexp    (Basic, gcn.arithmetic, gcn_fldexp)
Inst gcnfrexp_exp (Basic, gcn.arithmetic, gcn_frexp_exp)
Inst gcnfrexp_mant(Basic, gcn.arithmetic, gcn_frexp_mant)
Inst gcntrig_preop(Basic, gcn.arithmetic, gcn_trig_preop)

// ============================================================================
// GCN RegionAlloc

Req gcn_region_alloc
{ 
    type    = b32;

    s0 = imm.u32;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnregionalloc(Basic, gcn.memory, gcn_region_alloc)

// ============================================================================
// GCN LD

Req gcn_ld
{ 
    type    = u, s, f, b128;
    segment = gcn;
    align   = any;
    const   = none;
    eqclass = any;
    width   = any;

    { type = u, s, f ? d0 = (reg, reg.v) } 
    { type = b128    ? d0 = reg          }
    ;

    s1 = addr.tseg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnld(Mem, gcn.memory, gcn_ld)

// ============================================================================
// GCN ST

Req gcn_st
{ 
    type    = u, s, f, b128;
    segment = gcn;
    align   = any;
    const   = none;
    eqclass = any;
    width   = none;

    s1 = addr.tseg;
    s2 = null;
    s3 = null;
    s4 = null;

    { type = u, s, f ? s0 = (reg, reg.v, imm) }
    { type = b128    ? s0 = reg               }
    ;
}

Inst gcnst(Mem, gcn.memory, gcn_st)

// ============================================================================
// GCN ATOMIC

Req gcn_atomic
{ 
    type    = (b, s, u)(32, 64);
    atmop   = generic, exch, ld;
    segment = gcn;
    memscp  = any;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = reg, imm }
    { atmop = and, or, xor, exch ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = inc, dec           ? type = (u   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = ld                 ? type = (b   )(32, 64); memord = ld;  s2 = null;     s3 = null     }
    ;

    d0 = reg;
    s1 = addr.seg;
    s4 = null;
}

Inst gcnatomic(Atomic, gcn.atomic.memory, gcn_atomic)

// ============================================================================
// GCN ATOMICNORET

Req gcn_atomic_noret
{ 
    type    = (b, s, u)(32, 64);
    atmop   = generic, st;
    segment = gcn;
    memscp  = any;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord = any; s2 = reg, imm }
    { atmop = and, or, xor       ? type = (b   )(32, 64); memord = any; s2 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord = any; s2 = null     }
    { atmop = inc, dec           ? type = (u   )(32, 64); memord = any; s2 = null     }
    { atmop = st                 ? type = (b   )(32, 64); memord = st;  s2 = null     }
    ;

    s0 = addr.seg;
    s1 = reg, imm;
    s3 = null;
    s4 = null;
}

Inst gcnatomicnoret(Atomic, gcn.atomic.memory, gcn_atomic_noret)

// ============================================================================
// GCN ATOMIC_APPEND, ATOMIC_CONSUME

Req gcn_append_consume
{ 
    type    = u32;
    segment = gcn;

    d0 = reg;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnappend (Addr, gcn.atomic.memory, gcn_append_consume)
Inst gcnconsume(Addr, gcn.atomic.memory, gcn_append_consume)

// ============================================================================
// GCN Media Operations

Req gcn_msad
{ 
    type    = b32;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req gcn_qsad
{ 
    type    = b64;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req gcn_mqsad
{ 
    type    = b64;

    d0 = reg;
    s1 = (reg, imm);
    s2 = (reg, imm).b32;
    s3 = reg;
    s4 = null;
}

Req gcn_mqsad4
{ 
    type    = b32;

    d0 = reg.v4;
    s1 = (reg, imm).b64;
    s2 = (reg, imm);
    s3 = reg.v4;
    s4 = null;
}

Inst gcnmsad(Basic, gcn.misc, gcn_msad)
Inst gcnsadw(Basic, gcn.misc, gcn_msad)
Inst gcnsadd(Basic, gcn.misc, gcn_msad)
                                                              
Inst gcnqsad(Basic, gcn.misc, gcn_qsad)

Inst gcnmqsad (Basic, gcn.misc, gcn_mqsad)
Inst gcnmqsad4(Basic, gcn.misc, gcn_mqsad4)

// ============================================================================
// GCN Sleep and Priority

Req gcn_slp_prt
{ 
    type    = u32;

    s0 = reg, imm;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnsleep   (Basic, gcn.misc, gcn_slp_prt)
Inst gcnpriority(Basic, gcn.misc, gcn_slp_prt)

// ============================================================================
// GCN Block Exchange

Req gcn_b4xchg
{ 
    type    = b32;

    d0 = reg;
    s1 = reg;
    s2 = imm;
    s3 = null;
    s4 = null;
}

Inst gcnb4xchg (Basic, gcn.misc, gcn_b4xchg)
Inst gcnb32xchg(Basic, gcn.misc, gcn_b4xchg)


// FIXME: add all checks currently implemented in validator