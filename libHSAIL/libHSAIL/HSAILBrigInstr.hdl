// ============================================================================
// ============================================================================
// PROPERTIES
// ============================================================================
// ============================================================================

// ============================================================================
// Instruction/operand type

BrigProp type =

    none,

    b  = b(1, 8, 16, 32, 64, 128),
    s  = s(8, 16, 32, 64),
    u  = u(8, 16, 32, 64),
    f  = f(16, 32, 64),

    sx.32  = s(8x4, 16x2),
    sx.64  = s(8x8, 16x4, 32x2),
    sx.128 = s(8x16, 16x8, 32x4, 64x2),

    ux.32  = u(8x4, 16x2),
    ux.64  = u(8x8, 16x4, 32x2),
    ux.128 = u(8x16, 16x8, 32x4, 64x2),

    fx.32  = f(16x2),
    fx.64  = f(16x4, 32x2),
    fx.128 = f(16x8, 32x4, 64x2),

    roimg, rwimg, woimg, samp, sig32, sig64;

Alias sx = sx.(32, 64, 128);
Alias ux = ux.(32, 64, 128);
Alias fx = fx.(32, 64, 128);

Alias x    = (s, u, f)x;
Alias x.32 = (s, u, f)x.32;
Alias x.64 = (s, u, f)x.64;

Alias s8x  = s(8x4, 8x8, 8x16);
Alias s16x = s(16x2, 16x4, 16x8);
Alias s32x = s(32x2, 32x4);
Alias s64x = s(64x2);

Alias u8x  = u(8x4, 8x8, 8x16);
Alias u16x = u(16x2, 16x4, 16x8);
Alias u32x = u(32x2, 32x4);
Alias u64x = u(64x2);

Alias f16x = f(16x2, 16x4, 16x8);
Alias f32x = f(32x2, 32x4);
Alias f64x = f(64x2);

Alias opaque = roimg, rwimg, woimg, samp, sig32, sig64;
Alias img    = roimg, rwimg, woimg, samp;
Alias sig    = sig32, sig64;

Clone stype;   ExtPropName sourceType;  // src type
Clone itype;   ExtPropName imageType;   // image type
Clone ctype;   ExtPropName coordType;   // coord type
Clone sigtype; ExtPropName signalType;  // signal type

// ============================================================================
// Segment

BrigProp segment =
    none,
    flat,
    global,
    group,
    private,
    kernarg,
    readonly,
    spill,
    arg,
    amd.gcn;

Alias any      = global, group, private, spill, arg, flat, kernarg, readonly;
Alias writable = global, group, private, spill, arg, flat;
Alias std      = global, group, private, spill, arg;
Alias gcn      = amd.gcn;

// ============================================================================
// Special type checks

MetaProp typesize =
    atomic, // type size must be 32 for small model and 32/64 for large model
    model,  // type size must be 32 or 64 depending on machine model
    signal, // type size must be sig32 or sig64 depending on machine model
    seg;    // type must be b32/b64 depending on _instruction_ segment

Affects type, segment;

MetaProp stypesize = model, seg;

Affects stype;

// ============================================================================
// CMP Operators

BrigProp compare =
    eq,   ne,   lt,   le,   gt,   ge,
    equ,  neu,  ltu,  leu,  gtu,  geu,
    seq,  sne,  slt,  sle,  sgt,  sge,
    sequ, sneu, sltu, sleu, sgeu, sgtu,

    num,  snum,
    nan,  snan;

// ============================================================================
// Packing

BrigProp pack =
    none,
    p, s,
    pp, ps, sp, ss,
    ppsat, pssat, spsat, sssat,
    ssat, psat;

Alias bin       = pp, ps, sp, ss, ppsat, pssat, spsat, sssat;
Alias bin.nosat = pp, ps, sp, ss;

PropAccessor packEx;

// ============================================================================
// Rounding

BrigProp round =
    none,
    float   = (float_default, float_near_even, float_zero, float_plus_infinity, float_minus_infinity).default,
    int     = (integer_near_even, integer_zero, integer_plus_infinity, integer_minus_infinity,
               integer_near_even_sat, integer_zero_sat, integer_plus_infinity_sat, integer_minus_infinity_sat,
               integer_signaling_near_even, integer_signaling_zero, integer_signaling_plus_infinity, integer_signaling_minus_infinity,
               integer_signaling_near_even_sat, integer_signaling_zero_sat, integer_signaling_plus_infinity_sat, integer_signaling_minus_infinity_sat).zero;

Attr default, zero; // Default values

PropAccessor roundEx;
CustomCheck;

// ============================================================================
// FTZ Modifier

BrigBitProp ftz;

PropAccessor ftzEx;
CustomCheck;

// ============================================================================
// Const Modifier

BrigBitProp const;

ExtPropName isConst;

// ============================================================================
// NoNull Modifier

BrigBitProp nonull;

ExtPropName isNoNull;

// ============================================================================
// Align Modifier

BrigProp align =
    none,
    1,
    2,
    4,
    8,
    16,
    32,
    64,
    128,
    256;

Alias any  = * / none;

BrigPrefix ALIGNMENT;

// ============================================================================
// Equivalence Class

ExtProp eqclass = 0, any;

ExtPropName equivClass;

// ============================================================================
// Memory Order

BrigProp memord =
    none,
    acq = sc_acquire,
    rel = sc_release,
    ar  = sc_acquire_release,
    rlx = relaxed;

Alias any  = * / none;
Alias wait = * / (none, ar, rel);
Alias ld   = * / (none, ar, rel);
Alias st   = * / (none, ar, acq);

BrigPrefix  MEMORY_ORDER;
ExtPropName memoryOrder;

// ============================================================================
// Memory Scope

BrigProp memscp =
    none,
    wv  = wavefront,
    wg  = workgroup,
    agt = agent,
    sys = system,
    wi  = workitem;

Alias std = wv, wg, agt, sys;

BrigPrefix  MEMORY_SCOPE;
ExtPropName memoryScope;

Clone memscpglobal; ExtPropName globalSegmentMemoryScope;

Clone memscpgroup; ExtPropName groupSegmentMemoryScope;

Clone memscpimage; ExtPropName imageSegmentMemoryScope;

// ============================================================================
// Atomic Operations

BrigProp atmop =
    generic     = (add, sub,
                   and, or, xor),
    atomic      = (wrapinc, wrapdec,
                   max, min),
    special     = (cas, exch, ld, st),
    wait        = (wait_eq, wait_ne, wait_lt, wait_gte),
    waittimeout = (waittimeout_eq, waittimeout_ne, waittimeout_lt, waittimeout_gte);

BrigPrefix   ATOMIC;
ExtPropName  atomicOperation;

Clone sigop; ExtPropName signalOperation;

// ============================================================================
// Image Geometry

BrigProp geometry =
    1d,  2d,  3d,
    1db, 1da, 2da,
    2ddepth, 2dadepth;

Alias any = *;

// ============================================================================
// Image Query

BrigProp iprop = width, height, depth, array, channeltype, channelorder;

Alias any = *;

BrigPrefix IMAGE_QUERY;
ExtPropName imageQuery;

// ============================================================================
// Sampler Query

BrigProp sprop = addressing, coord, filter;

Alias any = *;

BrigPrefix SAMPLER_QUERY;
ExtPropName samplerQuery;

// ============================================================================
// Width

BrigProp width =
    none,
    (1,
     2,
     4,
     8,
     16,
     32,
     64,
     128,
     256,
     512,
     1024,
     2048,
     4096,
     8192,
     16384,
     32768,
     65536,
     131072,
     262144,
     524288,
     1048576,
     2097152,
     4194304,
     8388608,
     16777216,
     33554432,
     67108864,
     134217728,
     268435456,
     536870912,
     1073741824,
     2147483648,
     wavesize,
     all).(1, wavesize, all); // suffix is the default value

Alias any.1    = *.1;
Alias any.all  = *.all;
Alias any.ws   = *.wavesize;
Alias wavesize = wavesize.wavesize;
Alias all      = all.all;

Attr all, wavesize, 1; // Default values

// ============================================================================
// Operands

OperandProp operand =
    null,
    jumptab, calltab, signature, // NB: no type
    arglist,                     // NB: no type
    lab,
    func, ifunc, //F1.0 remove ifunc & OPERAND_VAL_IFUNC
    kernel,
    fbarrier.u32,
    addr.(seg,              // 1) address size must match _instruction_ segment size;
                            // 2) if inst.segment=flat, address must be flat
                            // 3) addresses in arg and spill segments must include a symbol
                            // 4) if address includes a symbol, symbol.segment must be the same as instr.segment

          tseg),            // 1+2+3+4
                            // 5) opaque symbols used in address must match instruction type

    (imm0T2, imm0T3).u32,
    (reg, vec.2, vec.3, vec.4, imm, cnst).(b1, b32, b64, u32, u64, s32, s64, p2u, dtype, stype, ctype),
    reg.(samp, sig32, sig64, itype);

Alias reg    = reg.dtype;
Alias vec.2  = vec.2.dtype;
Alias vec.3  = vec.3.dtype;
Alias vec.4  = vec.4.dtype;
Alias imm    = imm.dtype;
Alias cnst   = cnst.dtype;

Alias vector = vec.(2, 3, 4);

Clone  d0, d1, s0, s1, s2, s3, s4;

Attr dtype, stype, ctype, itype, p2u, seg, tseg,
     b1, b32, b64, u32, u64, s32, s64, samp, sig32, sig64;

DependsOn type, stype, ctype, itype;

// ============================================================================
// Operands templates (frequently used cases)

Req d0.s1
{
    d0 = reg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req d0.s1.s2
{
    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = null;
    s4 = null;
}

Req  d0.s1.s2.s3
{
    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

// ============================================================================
// ============================================================================
// DESCRIPTION OF STANDARD HSAIL INSTRUCTIONS
// ============================================================================
// ============================================================================

// ============================================================================
// ADD, SUB

Req add
{
    type = (s, u)(32, 64), f, x;

    { type = (s, u)(32, 64) ? pack = none;      round = none;  ftz = none }
    { type = f              ? pack = none;      round = float; ftz = any  }
    { type = (s, u)x        ? pack = bin;       round = none;  ftz = none }
    { type = fx             ? pack = bin.nosat; round = float; ftz = any  }
    ;

    d0.s1.s2;
}

Inst add(Mod, arithmetic, add)
Inst sub(Mod, arithmetic, add)

// ============================================================================
// MAX, MIN

Req max
{
    type  = (s, u)(32, 64), f, x;
    round = none;

    { type = (s, u)(32, 64) ? pack = none;      ftz = none }
    { type = f              ? pack = none;      ftz = any  }
    { type = (s, u)x        ? pack = bin.nosat; ftz = none }
    { type = fx             ? pack = bin.nosat; ftz = any  }
    ;

    d0.s1.s2;
}

Inst max(Mod, arithmetic, max)
Inst min(Mod, arithmetic, max)

// ============================================================================
// MUL

Req mul
{
    type = (s, u)(32, 64), f, x;

    { type = (s, u)(32, 64); ? pack = none;      round = none;  ftz = none }
    { type = f               ? pack = none;      round = float; ftz = any  }
    { type = (s, u)x;        ? pack = bin;       round = none;  ftz = none }
    { type = fx              ? pack = bin.nosat; round = float; ftz = any  }
    ;

    d0.s1.s2;
}

Inst mul(Mod, arithmetic, mul)

// ============================================================================
// MULHI

Req mulhi
{
    type  = (s, u)(32, 64, x);
    round = none;
    ftz   = none;

    { type = (s, u)(32, 64); ? pack = none;      }
    { type = (s, u)x;        ? pack = bin.nosat; }
    ;

    d0.s1.s2;
}

Inst mulhi(Mod, arithmetic, mulhi)

// ============================================================================
// DIV

Req div
{
    type = (s, u)(32, 64), f, fx;

    { type = (s, u)(32, 64) ? pack = none;      round = none;  ftz = none }
    { type = f              ? pack = none;      round = float; ftz = any  }
    { type = fx             ? pack = bin.nosat; round = float; ftz = any  }
    ;

    d0.s1.s2;
}

Inst div(Mod, arithmetic, div)

// ============================================================================
// REM, CARRY, BORROW

Req rem
{
    type = (s, u)(32, 64);

    d0.s1.s2;
}

Inst rem   (Basic, arithmetic, rem)
Inst carry (Basic, arithmetic, rem)
Inst borrow(Basic, arithmetic, rem)

// ============================================================================
// NEG, ABS

Req neg
{
    type  = s(32, 64, x), f, fx;
    round = none;
    ftz   = none;

    { type = s(32, 64), f ? pack = none }
    { type = (s, f)x      ? pack = s, p }
    ;

    d0.s1;
}

Inst neg(Mod, arithmetic, neg)
Inst abs(Mod, arithmetic, neg)

// ============================================================================
// COPYSIGN

Req copysign
{
    type  = f, fx;
    round = none;
    ftz   = none;

    { type = f  ? pack = none      }
    { type = fx ? pack = bin.nosat }
    ;

    d0.s1.s2;
}

Inst copysign(Mod, arithmetic, copysign)

// ============================================================================
// FRACT

Req fract
{
    type  = f, fx;
    round = float;
    ftz   = any;

    { type = f  ? pack = none }
    { type = fx ? pack = p, s }
    ;

    d0.s1;
}

Inst fract(Mod, arithmetic, fract)

// ============================================================================
// SQRT

Req sqrt
{
    type  = f, fx;
    round = float;
    ftz   = any;

    { type = f  ? pack = none }
    { type = fx ? pack = p, s }
    ;

    d0.s1;
}

Inst sqrt(Mod, arithmetic, sqrt)

// ============================================================================
// CEIL, FLOOR, RINT, TRUNC

Req ceil
{
    type  = f, fx;
    round = none;
    ftz   = any;

    { type = f  ? pack = none }
    { type = fx ? pack = p, s }
    ;

    d0.s1;
}

Inst ceil (Mod, arithmetic, ceil)
Inst floor(Mod, arithmetic, ceil)
Inst rint (Mod, arithmetic, ceil)
Inst trunc(Mod, arithmetic, ceil)

// ============================================================================
// MUL24, MUL24HI

Req mul24
{
    type = (s, u)32;

    d0.s1.s2;
}

Inst mul24  (Basic, arithmetic, mul24)
Inst mul24hi(Basic, arithmetic, mul24)

// ============================================================================
// MAD24, MAD24HI

Req mad24
{
    type = (s, u)32;

    d0.s1.s2.s3;
}

Inst mad24  (Basic, arithmetic, mad24)
Inst mad24hi(Basic, arithmetic, mad24)

// ============================================================================
// MAD

Req mad
{
    type  = (s, u)(32, 64), f;

    { type = (s, u)(32, 64) ? pack = none; round = none;  ftz = none }
    { type = f              ? pack = none; round = float; ftz = any  }
    ;

    d0.s1.s2.s3;
}

Inst mad(Mod, arithmetic, mad)

// ============================================================================
// FMA

Req fma
{
    type  = f;
    pack  = none;
    round = float;
    ftz   = any;

    d0.s1.s2.s3;
}

Inst fma(Mod, arithmetic, fma)

// ============================================================================
// SHL, SHR

Req shift
{
    type = (s, u)(32, 64, x);

    d0 = reg;
    s1 = (reg, imm);
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst shl(Basic, arithmetic, shift)
Inst shr(Basic, arithmetic, shift)

// ============================================================================
// AND, OR, XOR

Req and
{
    type = b(1, 32, 64);

    d0.s1.s2;
}

Inst and(Basic, arithmetic, and)
Inst or (Basic, arithmetic, and)
Inst xor(Basic, arithmetic, and)

// ============================================================================
// NOT

Req not
{
    type = b(1, 32, 64);

    d0.s1;
}

Inst not(Basic, arithmetic, not)

// ============================================================================
// POPCOUNT

Req popcount
{
    type  = u32;
    stype = b(32, 64);

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst popcount(Source.Type, arithmetic, popcount)

// ============================================================================
// BITMASK

Req bitmask
{
    type = b(32, 64);

    d0 = reg;
    s1 = (reg, imm).u32;
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst bitmask(Basic, arithmetic, bitmask)

// ============================================================================
// BITSELECT

Req bitselect
{
    type = b(32, 64);

    d0.s1.s2.s3;
}

Inst bitselect(Basic, arithmetic, bitselect)

// ============================================================================
// BITREV

Req bitrev
{
    type = b(32, 64);

    d0.s1;
}

Inst bitrev(Basic, arithmetic, bitrev)

// ============================================================================
// BITEXTRACT

Req bitextract
{
    type = (s, u)(32, 64);

    d0 = reg;
    s1 = (reg, imm);
    s2 = (reg, imm).u32;
    s3 = (reg, imm).u32;
    s4 = null;
}

Inst bitextract(Basic, arithmetic, bitextract)

// ============================================================================
// BITINSERT

Req bitinsert
{
    type = (s, u)(32, 64);

    d0 = reg;
    s1 = (reg, imm);
    s2 = (reg, imm);
    s3 = (reg, imm).u32;
    s4 = (reg, imm).u32;
}

Inst bitinsert(Basic, arithmetic, bitinsert)

// ============================================================================
// FIRSTBIT, LASTBIT

Req firstbit
{
    type  = u32;
    stype = (s, u)(32, 64);

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst firstbit(Source.Type, arithmetic, firstbit)
Inst lastbit (Source.Type, arithmetic, firstbit)

// ============================================================================
// COMBINE

Req combine
{
    type  = b(64, 128);
    stype = b(32, 64);

    { type = b64;  stype = b32 ? s1 = vec.2.stype }
    { type = b128; stype = b64 ? s1 = vec.2.stype }
    { type = b128; stype = b32 ? s1 = vec.4.stype }
    ;

    d0 = reg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst combine(Source.Type, move, combine)

// ============================================================================
// EXPAND

Req expand
{
    type  = b(32, 64);
    stype = b(64, 128);

    { type = b32; stype = b64  ? d0 = vec.2 }
    { type = b32; stype = b128 ? d0 = vec.4 }
    { type = b64; stype = b128 ? d0 = vec.2 }
    ;

    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst expand(Source.Type, move, expand)

// ============================================================================
// MOV

Req mov
{
    type = b(1, 32, 64, 128), (s, u)(32, 64), f, opaque;

    d0 = reg;

    { type = b(1, 32, 64, 128), (s, u)(32, 64), f ? s1 = reg, imm }
    { type = opaque                               ? s1 = reg      }
    ;

    s2 = null;
    s3 = null;
    s4 = null;
}

Inst mov(Basic, move, mov)

// ============================================================================
// LDA

Req lda
{
    type    = u(32, 64);
    segment = global, group, private, flat, kernarg, readonly;

    typesize = seg;

    d0 = reg;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst lda(Addr, arithmetic, lda)

// ============================================================================
// SHUFFLE

Req shuffle
{
    type = x.(32, 64);

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = cnst.b32;  // WS is not allowed
    s4 = null;
}

Inst shuffle(Basic, arithmetic, shuffle)

// ============================================================================
// UNPACKLO, UNPACKHI

Req unpackx
{
    type = x.(32, 64);

    d0.s1.s2;
}

Inst unpacklo(Basic, arithmetic, unpackx)
Inst unpackhi(Basic, arithmetic, unpackx)

// ============================================================================
// PACK

Req pack
{
    type  = x;
    stype = (s, u)(32, 64), f;

    { type = s(8, 16, 32)x ? stype = s32 }
    { type = s64x          ? stype = s64 }
    { type = u(8, 16, 32)x ? stype = u32 }
    { type = u64x          ? stype = u64 }
    { type = f16x          ? stype = f16 }
    { type = f32x          ? stype = f32 }
    { type = f64x          ? stype = f64 }
    ;

    d0 = reg;
    s1 = reg, imm;
    s2 = (reg, imm).stype;
    s3 = (reg, imm).u32;
    s4 = null;
}

Inst pack(Source.Type, arithmetic, pack)

// ============================================================================
// UNPACK

Req unpack
{
    type  = (s, u)(32, 64), f;
    stype = x;

    { type = s32 ? stype = s(8, 16, 32)x }
    { type = s64 ? stype = s64x          }
    { type = u32 ? stype = u(8, 16, 32)x }
    { type = u64 ? stype = u64x          }
    { type = f16 ? stype = f16x          }
    { type = f32 ? stype = f32x          }
    { type = f64 ? stype = f64x          }
    ;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst unpack(Source.Type, arithmetic, unpack)

// ============================================================================
// CMOV

Req cmov
{
    type = b(1, 32, 64), x;

    d0 = reg;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;

    { type = b(1, 32, 64) ? s1 = (reg, imm).b1  }
    { type = x            ? s1 = (reg, imm).p2u } // convert packed type tAxB to unsigned uAxB. See packedType2uType
    ;
}

Inst cmov(Basic, arithmetic, cmov)

// ============================================================================
// CLASS

Req class
{
    type  = b1;
    stype = f;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, cnst).u32;
    s3 = null;
    s4 = null;
}

Inst class(Source.Type, arithmetic, class)

// ============================================================================
// NSIN, NCOS, NLOG2, NEXP2, NSQRT, NRSQRT, NRCP, NFMA

Req trig32
{
    type = f32;

    d0.s1;
}

Req trig
{
    type = f;

    d0.s1;
}

Req nfma
{
    type = f;

    d0.s1.s2.s3;
}

Inst nsin  (Basic, arithmetic, trig32)
Inst ncos  (Basic, arithmetic, trig32)
Inst nlog2 (Basic, arithmetic, trig32)
Inst nexp2 (Basic, arithmetic, trig32)

Inst nsqrt (Basic, arithmetic, trig)
Inst nrsqrt(Basic, arithmetic, trig)
Inst nrcp  (Basic, arithmetic, trig)

Inst nfma  (Basic, arithmetic, nfma)

// ============================================================================
// BITALIGN, BYTEALIGN

Req align
{
    type = b32;

    d0.s1.s2.s3;
}

Inst bitalign (Basic, arithmetic, align)
Inst bytealign(Basic, arithmetic, align)

// ============================================================================
// LERP

Req lerp
{
    type = u8x4;

    d0.s1.s2.s3;
}

Inst lerp(Basic, arithmetic, lerp)

// ============================================================================
// SAD

Req sad
{
    type  = u32;
    stype = u32, u8x4, u16x2;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).stype;
    s3 = (reg, imm).u32;
    s4 = null;
}

Inst sad(Source.Type, arithmetic, sad)

// ============================================================================
// SADHI

Req sadhi
{
    type  = u16x2;
    stype = u8x4;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).stype;
    s3 = reg, imm;
    s4 = null;
}

Inst sadhi(Source.Type, arithmetic, sadhi)

// ============================================================================
// PACKCVT

Req packcvt
{
    type  = u8x4;
    stype = f32;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).stype;
    s3 = (reg, imm).stype;
    s4 = (reg, imm).stype;
}

Inst packcvt(Source.Type, arithmetic, packcvt)

// ============================================================================
// UNPACKCVT

Req unpackcvt
{
    type  = f32;
    stype = u8x4;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = imm0T3.u32;
    s3 = null;
    s4 = null;
}

Inst unpackcvt(Source.Type, arithmetic, unpackcvt)

// ============================================================================
// SEGMENTP

Req segmentp
{
    type    = b1;
    stype   = u(32, 64);
    segment = global, group, private;
    nonull  = any;

    stypesize = model;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst segmentp(Seg.Cvt, arithmetic, segmentp)

// ============================================================================
// FTOS, STOF

Req f2s
{
    type    = u(32, 64);
    stype   = u(32, 64);
    segment = group, private;
    nonull  = any;

    typesize  = seg;
    stypesize = model;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req s2f
{
    type    = u(32, 64);
    stype   = u(32, 64);
    segment = group, private;
    nonull  = any;

    typesize  = model;
    stypesize = seg;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst ftos(Seg.Cvt, arithmetic, f2s)
Inst stof(Seg.Cvt, arithmetic, s2f)

// ============================================================================
// CMP

Req cmp
{
    type  = b1,    (s, u)(32, 64), f, ux;
    stype = b1, (b, s, u)(32, 64), f, x;

    { stype = b1, (b, s, u)(32, 64), f ? type = b1, (s, u)(32, 64), f }
    { stype = (s, u)8x4                ? type = u8x4                  }
    { stype = (s, u)8x8                ? type = u8x8                  }
    { stype = (s, u)8x16               ? type = u8x16                 }
    { stype = (s, u, f)16x2            ? type = u16x2                 }
    { stype = (s, u, f)16x4            ? type = u16x4                 }
    { stype = (s, u, f)16x8            ? type = u16x8                 }
    { stype = (s, u, f)32x2            ? type = u32x2                 }
    { stype = (s, u, f)32x4            ? type = u32x4                 }
    { stype = (s, u, f)64x2            ? type = u64x2                 }
    ;

    { stype = b(1, 32, 64)   ? ftz = none; pack = none; compare = eq, ne                 }
    { stype = (s, u)(32, 64) ? ftz = none; pack = none; compare = eq, ne, lt, le, gt, ge }
    { stype = f              ? ftz = any;  pack = none; compare = *                      }
    { stype = (s, u)x        ? ftz = none; pack = pp;   compare = eq, ne, lt, le, gt, ge }
    { stype = fx             ? ftz = any;  pack = pp;   compare = *                      }
    ;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = (reg, imm).stype;
    s3 = null;
    s4 = null;
}

Inst cmp(Cmp, arithmetic, cmp)

// ============================================================================
// CVT

Req cvt
{
    type  = b1, s, u, f;
    stype = b1, s, u, f;

    { type = b1       ? stype = s, u, f                      }
    { type = (s, u)8  ? stype = b1, (s, u)(   16, 32, 64), f }
    { type = (s, u)16 ? stype = b1, (s, u)(8,     32, 64), f }
    { type = (s, u)32 ? stype = b1, (s, u)(8, 16,     64), f }
    { type = (s, u)64 ? stype = b1, (s, u)(8, 16, 32    ), f }
    { type = f16      ? stype = * / f16                      }
    { type = f32      ? stype = * / f32                      }
    { type = f64      ? stype = * / f64                      }
    ;

    { stype = b1, s, u; type = b1, s, u  ? round = none;  ftz = none }
    { stype = b1;       type = f         ? round = none;  ftz = none }
    { stype = s, u;     type = f         ? round = float; ftz = none }
    { stype = f;        type = b1        ? round = none;  ftz = any  }
    { stype = f;        type = s, u      ? round = int;   ftz = any  }
    { stype = f32;      type = f16       ? round = float; ftz = any  }
    { stype = f64;      type = f(16, 32) ? round = float; ftz = any  }
    { stype = f;        type = f         ? round = none;  ftz = any  } // This case must go last!
    ;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst cvt(Cvt, arithmetic, cvt)

// ============================================================================
// LD

Req ld
{
    type    = u, s, f, b128, opaque;
    segment = any;
    align   = any;
    const   = any;
    eqclass = any;
    width   = any.1;

    { segment = global, readonly, flat              ? const = any  }
    { segment = group, private, kernarg, spill, arg ? const = none }
    ;

    d0 = reg, vector;
    s1 = addr.tseg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst ld(Mem, memory, ld)

// ============================================================================
// ST

Req st
{
    type    = u, s, f, b128, opaque;
    segment = writable;
    align   = any;
    const   = none;
    eqclass = any;
    width   = none;

    { type = u, s, f, b128, sig ? segment = writable }
    { type = img                ? segment = arg      } // img/samp types are only allowed if segment is arg
    ;

    s0 = reg, vector, imm;
    s1 = addr.tseg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst st(Mem, memory, st)

// ============================================================================
// ATOMIC

Req atomic
{
    type    = (b, s, u)(32, 64);
    atmop   = generic, atomic, cas, exch, ld;
    segment = global, group, flat;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = reg, imm }
    { atmop = and, or, xor, exch ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = wrapinc, wrapdec   ? type = (u   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = ld                 ? type = (b   )(32, 64); memord = ld;  s2 = null;     s3 = null     }
    ;

    { segment = global, flat ? memscp = wv, wg, agt, sys }
    { segment = group        ? memscp = wv, wg           }
    ;

    d0 = reg;
    s1 = addr.seg;
    s4 = null;
}

Inst atomic(Atomic, atomic.memory, atomic)

// ============================================================================
// ATOMICNORET

Req atomic.noret
{
    type    = (b, s, u)(32, 64);
    atmop   = generic, atomic, st;
    segment = global, group, flat;
    eqclass = any;

    typesize = atomic;

    { atmop = and, or, xor       ? type = (b   )(32, 64); memord  = any }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord  = any }
    { atmop = wrapinc, wrapdec   ? type = (u   )(32, 64); memord  = any }
    { atmop = st                 ? type = (b   )(32, 64); memord  = st  }
    ;

    { segment = global, flat ? memscp = wv, wg, agt, sys }
    { segment = group        ? memscp = wv, wg           }
    ;

    s0 = addr.seg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst atomicnoret(Atomic, atomic.memory, atomic.noret)

// ============================================================================
// Signal Operations

Req signal
{
    type    = (b, s, u)(32, 64);
    sigtype = sig32, sig64;
    sigop   = generic, cas, exch, ld, wait, waittimeout;
    memord  = any;
    
    typesize = model;

    { type = (b, s, u)32 ? sigtype = sig32; s1 = reg.sig32 }
    { type = (b, s, u)64 ? sigtype = sig64; s1 = reg.sig64 }
    ;

    { sigop = ld                 ? type = (b   )(32, 64); memord = ld;   s2 = null;     s3 = null           }
    { sigop = and, or, xor, exch ? type = (b   )(32, 64); memord = any;  s2 = reg, imm; s3 = null           }
    { sigop = cas                ? type = (b   )(32, 64); memord = any;  s2 = reg, imm; s3 = reg, imm       }
    { sigop = add, sub           ? type = (s, u)(32, 64); memord = any;  s2 = reg, imm; s3 = null           }
    { sigop = wait               ? type = (s   )(32, 64); memord = wait; s2 = reg, imm; s3 = null           }
    { sigop = waittimeout        ? type = (s   )(32, 64); memord = wait; s2 = reg, imm; s3 = (reg, imm).u64 }
    ;

    d0 = reg;
    s4 = null;
}

Req signal.noret
{
    type    = (b, s, u)(32, 64);
    sigtype = sig32, sig64;
    sigop   = generic, st;
    memord  = any;

    typesize = model;

    { type = (b, s, u)32 ? sigtype = sig32; s0 = reg.sig32 }
    { type = (b, s, u)64 ? sigtype = sig64; s0 = reg.sig64 }
    ;

    { sigop = st           ? type = (b   )(32, 64); memord = st  }
    { sigop = and, or, xor ? type = (b   )(32, 64); memord = any }
    { sigop = add, sub     ? type = (s, u)(32, 64); memord = any }
    ;

    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst signal     (Signal, sync, signal)
Inst signalnoret(Signal, sync, signal.noret)

// ============================================================================
// RD_IMAGE

Req rdimage
{
    type     = (s, u, f)32;
    itype    = roimg;
    ctype    = (s, f)32;
    geometry = 1d, 2d, 3d, 1da, 2da, 2ddepth, 2dadepth;
    eqclass  = any;

    s1 = reg.itype;
    s2 = reg.samp;
    s4 = null;

    { geometry = 1d       ? d0 = vec.4; s3 = (reg, imm).ctype }
    { geometry = 2d, 1da  ? d0 = vec.4; s3 = vec.2.ctype      }
    { geometry = 3d, 2da  ? d0 = vec.4; s3 = vec.3.ctype      }
    { geometry = 2ddepth  ? d0 = reg;   s3 = vec.2.ctype      }
    { geometry = 2dadepth ? d0 = reg;   s3 = vec.3.ctype      }
    ;
}

Inst rdimage(Image, image, rdimage)

// ============================================================================
// LDIMAGE, STIMAGE

Req ld.st.image
{
    type     = (s, u, f)32;
    ctype    = u32;
    geometry = any;
    eqclass  = any;
}

Req ld.image
{
    ld.st.image;
    itype = roimg, rwimg;

    { geometry = 1d, 1db  ? d0 = vec.4; s2 = (reg, imm).ctype }
    { geometry = 2d, 1da  ? d0 = vec.4; s2 = vec.2.ctype      }
    { geometry = 3d, 2da  ? d0 = vec.4; s2 = vec.3.ctype      }
    { geometry = 2ddepth  ? d0 = reg;   s2 = vec.2.ctype      }
    { geometry = 2dadepth ? d0 = reg;   s2 = vec.3.ctype      }
    ;

    s1 = reg.itype;
    s3 = null;
    s4 = null;
}

Req st.image
{
    ld.st.image;
    itype = woimg, rwimg;

    { geometry = 1d, 1db  ? s0 = vec.4; s2 = (reg, imm).ctype }
    { geometry = 2d, 1da  ? s0 = vec.4; s2 = vec.2.ctype      }
    { geometry = 3d, 2da  ? s0 = vec.4; s2 = vec.3.ctype      }
    { geometry = 2ddepth  ? s0 = reg;   s2 = vec.2.ctype      }
    { geometry = 2dadepth ? s0 = reg;   s2 = vec.3.ctype      }
    ;

    s1 = reg.itype;
    s3 = null;
    s4 = null;
}

Inst ldimage(Image, image, ld.image)
Inst stimage(Image, image, st.image)

// ============================================================================
// QUERY

Req queryimage
{
    type     = u32;
    itype    = roimg, rwimg, woimg;
    geometry = any;
    iprop    = any;

    { iprop = width, channeltype, channelorder ? geometry = any                            }
    { iprop = depth                            ? geometry = 3d                             }
    { iprop = array                            ? geometry = 1da, 2da, 2dadepth             }
    { iprop = height                           ? geometry = 2d, 3d, 2da, 2ddepth, 2dadepth }
    ;

    d0 = reg;
    s1 = reg.itype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req querysampler
{
    type  = u32;
    sprop = any;

    d0 = reg;
    s1 = reg.samp;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst queryimage  (Query.Image,   image, queryimage)
Inst querysampler(Query.Sampler, image, querysampler)

// ============================================================================
// IMAGEFENCE

Req imagefence
{
    type = none;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst imagefence(Basic, image, imagefence)

// ============================================================================
// BR

Req br
{
    type  = none;
    width = all;

    s0 = lab;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst br(Br, branch, br)

// ============================================================================
// CBR

Req cbr
{
    type  = b1;
    width = any.1;

    s0 = reg, imm;
    s1 = lab;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst cbr(Br, branch, cbr)

// ============================================================================
// SBR

Req sbr
{
    type  = u(32, 64);
    width = any.1;

    s0 = reg, imm;
    s1 = jumptab;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst sbr(Br, branch, sbr)

// ============================================================================
// BARRIER

Req barrier
{
    type  = none;
    width = any.all;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst barrier(Br, sync, barrier)

// ============================================================================
// WAVEBARRIER

Req wavebarrier
{
    type  = none;
    width = wavesize;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst wavebarrier(Br, sync, wavebarrier)

// ============================================================================
// FBAR*

Req fbar.none
{
    type = none;

    s0 = (reg, fbarrier).u32;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req fbar.width
{
    type  = none;
    width = any.ws;

    s0 = (reg, fbarrier).u32;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req ldf
{
    type = u32;

    s0 = reg;
    s1 = fbarrier.u32;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst initfbar   (Basic, sync, fbar.none)
Inst releasefbar(Basic, sync, fbar.none)
Inst joinfbar   (Br,    sync, fbar.width)
Inst leavefbar  (Br,    sync, fbar.width)
Inst waitfbar   (Br,    sync, fbar.width)
Inst arrivefbar (Br,    sync, fbar.width)
Inst ldf        (Basic, sync, ldf)

// ============================================================================
// MEMFENCE

Req memfence
{
    type         = none;
    memord       = acq, rel, ar;
    memscpglobal = wv, wg, agt, sys;
    memscpgroup  = wv, wg, agt, sys;
    memscpimage  = none;

    { memscpglobal = wv  ? memscpgroup = wv  }
    { memscpglobal = wg  ? memscpgroup = wg  }
    { memscpglobal = agt ? memscpgroup = agt }
    { memscpglobal = sys ? memscpgroup = sys }
    ;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst memfence(Mem.Fence, sync, memfence)

// ============================================================================
// ACTIVELANEMASK

Req activelanemask
{
    type  = b64;
    stype = b1;
    width = any.1;

    d0 = vec.4;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst activelanemask(Lane, sync, activelanemask)

// ============================================================================
// ACTIVELANECOUNT

Req activelanecount
{
    type  = u32;
    stype = b1;
    width = any.1;

    d0 = reg;
    s1 = (reg, imm).stype;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst activelanecount(Lane, sync, activelanecount)

// ============================================================================
// ACTIVELANEID

Req activelaneid
{
    type  = u32;
    stype = none;
    width = any.1;

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst activelaneid(Lane, sync, activelaneid)

// ============================================================================
// ACTIVELANEPERMUTE

Req activelanepermute
{
    type  = b(1, 32, 64, 128);
    stype = none;
    width = any.1;

    d0 =  reg;
    s1 =  reg, imm;
    s2 = (reg, imm).u32;
    s3 =  reg, imm;
    s4 = (reg, imm).b1;
}

Inst activelanepermute(Lane, sync, activelanepermute)

// ============================================================================
// CALL

Req call
{
    type  = none;
    width = all;

    s0 = arglist;
    s1 = func;
    s2 = arglist;
    s3 = null;
    s4 = null;
}

Inst call(Br, branch, call)

// ============================================================================
// SCALL

Req scall
{
    type  = u(32, 64);
    width = any.1;

    s0 = arglist;
    s1 = reg, imm;
    s2 = arglist;
    s3 = calltab;
    s4 = null;
}

Inst scall(Br, branch, scall)

// ============================================================================
// ICALL

Req icall
{
    type  = u(32, 64);
    width = any.1;
    
    typesize = model;

    s0 = arglist;
    s1 = reg;
    s2 = arglist;
    s3 = signature;
    s4 = null;
}

Inst icall(Br, branch, icall)

// ============================================================================
// RET

Req ret
{
    type = none;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst ret(Basic, branch, ret)

// ============================================================================
// ALLOCA

Req alloca
{
    type    = u32;
    segment = private;
    align   = any;
    const   = none;
    eqclass = 0;
    width   = none;

    s0 = reg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst alloca(Mem, misc, alloca)

// ============================================================================
// WORKITEMID, etc

Req basic.dst.u32
{
    type = u32;

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req basic.dst.u32.u64
{
    type = u(32, 64);

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req basic.dst.u32.dim
{
    type = u32;

    d0 = reg;
    s1 = imm0T2.u32;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req basic.dst.u32.u64.dim
{
    type = u(32, 64);

    d0 = reg;
    s1 = imm0T2.u32;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req spec.except
{
    type = u32;

    s0 = cnst; // WS is not allowed
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req spec.clock
{
    type = u64;

    d0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req packet
{
    type = sig32, sig64;
    
    typesize = signal;

    s0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req nop
{
    type = none;

    s0 = null;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst cuid                   (Basic, misc, basic.dst.u32)
Inst dim                    (Basic, misc, basic.dst.u32)
Inst currentworkitemflatid  (Basic, misc, basic.dst.u32)
Inst getdetectexcept        (Basic, misc, basic.dst.u32)
Inst laneid                 (Basic, misc, basic.dst.u32)
Inst maxcuid                (Basic, misc, basic.dst.u32)
Inst maxwaveid              (Basic, misc, basic.dst.u32)
Inst waveid                 (Basic, misc, basic.dst.u32)
Inst workitemflatid         (Basic, misc, basic.dst.u32)
Inst groupbaseptr           (Basic, misc, basic.dst.u32)

Inst workitemflatabsid      (Basic, misc, basic.dst.u32.u64)

Inst currentworkgroupsize   (Basic, misc, basic.dst.u32.dim)
Inst gridgroups             (Basic, misc, basic.dst.u32.dim)
Inst workgroupid            (Basic, misc, basic.dst.u32.dim)
Inst workgroupsize          (Basic, misc, basic.dst.u32.dim)
Inst workitemid             (Basic, misc, basic.dst.u32.dim)

Inst gridsize               (Basic, misc, basic.dst.u32.u64.dim)
Inst workitemabsid          (Basic, misc, basic.dst.u32.u64.dim)

Inst cleardetectexcept      (Basic, misc, spec.except)
Inst setdetectexcept        (Basic, misc, spec.except)

Inst clock                  (Basic, misc, spec.clock)
Inst packetid               (Basic, misc, spec.clock)

Inst packetcompletionsig    (Basic, misc, packet)

Inst nop                    (Basic, misc, nop)

// ============================================================================
// NULLPTR, KERNARGBASEPTR

Req ptr.model
{
    type = u(32, 64);
    
    typesize = model;

    s0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req nullptr
{
    type    = u(32, 64);
    segment = flat, group, private, kernarg;
    
    typesize = seg;

    s0 = reg;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst kernargbaseptr (Basic, misc, ptr.model)
Inst nullptr        (Seg,   misc, nullptr)

// ============================================================================
// User Mode Queue Operations

Req addq
{
    type    = u64;
    segment = flat, global;
    memord  = any;

    d0 = reg;
    s1 = addr.seg;
    s2 = reg, imm;
    s3 = null;
    s4 = null;
}

Req casq
{
    type    = u64;
    segment = flat, global;
    memord  = any;

    d0 = reg;
    s1 = addr.seg;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req ldq
{
    type    = u64;
    segment = flat, global;
    memord  = rlx, acq;

    d0 = reg;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req stq
{
    type    = u64;
    segment = flat, global;
    memord  = rlx, rel;

    s0 = addr.seg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst addqueuewriteindex(Queue, misc, addq)
Inst casqueuewriteindex(Queue, misc, casq)
Inst ldqueuereadindex  (Queue, misc, ldq )
Inst ldqueuewriteindex (Queue, misc, ldq )
Inst stqueuereadindex  (Queue, misc, stq )
Inst stqueuewriteindex (Queue, misc, stq )

// ============================================================================

Req debugtrap
{
    type = u32;

    s0 = reg, imm;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst debugtrap(Basic, misc, debugtrap)

// ============================================================================
// ============================================================================
// DESCRIPTION OF GCN INSTRUCTIONS
// ============================================================================
// ============================================================================

// ============================================================================
// GCN MADU, MADS

Req gcn_madu
{
    type = b32;

    d0 = reg.u64;
    s1 = (reg, imm).u32;
    s2 = (reg, imm).u32;
    s3 = (reg, imm).u64;
    s4 = null;
}

Req gcn_mads
{
    type = b32;

    d0 = reg.s64;
    s1 = (reg, imm).s32;
    s2 = (reg, imm).s32;
    s3 = (reg, imm).s64;
    s4 = null;
}

Inst gcnmadu(Basic, gcn.arithmetic, gcn_madu)
Inst gcnmads(Basic, gcn.arithmetic, gcn_mads)

// ============================================================================
// GCN MIN, MAX, MIN3, MED3, MAX3, BFM

Req gcn_min_max
{
    type = (s, u)32, f(32, 64);
    d0.s1.s2;
}

Req gcn_min_max_med3
{
    type = (s, u, f)32;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req gcn_bfm
{
    type = b32;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = null;
    s4 = null;
}

Inst gcnmin (Basic, gcn.arithmetic, gcn_min_max)
Inst gcnmax (Basic, gcn.arithmetic, gcn_min_max)
Inst gcnmin3(Basic, gcn.arithmetic, gcn_min_max_med3)
Inst gcnmed3(Basic, gcn.arithmetic, gcn_min_max_med3)
Inst gcnmax3(Basic, gcn.arithmetic, gcn_min_max_med3)
Inst gcnbfm (Basic, gcn.arithmetic, gcn_bfm)

// ============================================================================
// GCN DIVRELAXED, DIVRELAXEDNARROW

Req gcn_div_relaxed
{
    type  = f32;
    pack  = none;
    round = none; // Implementation should always round to near.
    ftz   = any;
    d0.s1.s2;
}

Req gcn_div_relaxed_narrow
{
    type = f32;
    d0.s1.s2;
}

Inst gcndivrelaxed(Mod, gcn.arithmetic, gcn_div_relaxed)
Inst gcndivrelaxednarrow(Basic, gcn.arithmetic, gcn_div_relaxed_narrow)

// ============================================================================
// GCN FLDEXP, FREXP_EXP, FREXP_MANT, FREXP_PREOP

Req gcn_fldexp
{
    type  = f(32, 64);
    pack  = none;
    round = none; // Implementation should always round to near.
    ftz   = any;

    d0 = reg;
    s1 = reg, imm;
    s2 = (reg, imm).s32;
    s3 = null;
    s4 = null;
}

Req gcn_frexp_exp
{
    type  = f(32, 64);
    pack  = none;
    round = none; // No rounding implied.
    ftz   = any;

    d0 = reg.s32;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req gcn_frexp_mant
{
    type  = f(32, 64);
    pack  = none;
    round = none; // No rounding implied.
    ftz   = any;

    d0 = reg;
    s1 = reg, imm;
    s2 = null;
    s3 = null;
    s4 = null;
}

Req gcn_trig_preop
{
    type  = f64;
    pack  = none;
    round = none; // Always rounds to zero.
    ftz   = any;

    d0 = reg;
    s1 = reg, imm;
    s2 = (reg, imm).u32;
    s3 = null;
    s4 = null;
}

Inst gcnfldexp    (Mod, gcn.arithmetic, gcn_fldexp)
Inst gcnfrexp_exp (Mod, gcn.arithmetic, gcn_frexp_exp)
Inst gcnfrexp_mant(Mod, gcn.arithmetic, gcn_frexp_mant)
Inst gcntrig_preop(Mod, gcn.arithmetic, gcn_trig_preop)

// ============================================================================
// GCN RegionAlloc

Req gcn_region_alloc
{
    type = b32;

    s0 = imm.u32;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnregionalloc(Basic, gcn.memory, gcn_region_alloc)

// ============================================================================
// GCN LD

Req gcn_ld
{
    type    = u, s, f, b128;
    segment = gcn;
    align   = any;
    const   = none;
    eqclass = any;
    width   = any.1;

    d0 = reg, vector;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnld(Mem, gcn.memory, gcn_ld)

// ============================================================================
// GCN ST

Req gcn_st
{
    type    = u, s, f, b128;
    segment = gcn;
    align   = any;
    const   = none;
    eqclass = any;
    width   = none;

    s0 = reg, vector, imm;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnst(Mem, gcn.memory, gcn_st)

// ============================================================================
// GCN ATOMIC

Req gcn_atomic
{
    type    = (b, s, u)(32, 64);
    atmop   = generic, atomic, cas, exch, ld;
    segment = gcn;
    memscp  = wv, wg, agt, sys;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = reg, imm }
    { atmop = and, or, xor, exch ? type = (b   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = wrapinc, wrapdec   ? type = (u   )(32, 64); memord = any; s2 = reg, imm; s3 = null     }
    { atmop = ld                 ? type = (b   )(32, 64); memord = ld;  s2 = null;     s3 = null     }
    ;

    d0 = reg;
    s1 = addr.seg;
    s4 = null;
}

Inst gcnatomic(Atomic, gcn.atomic.memory, gcn_atomic)

// ============================================================================
// GCN ATOMICNORET

Req gcn_atomic_noret
{
    type    = (b, s, u)(32, 64);
    atmop   = generic, atomic, st;
    segment = gcn;
    memscp  = wv, wg, agt, sys;
    eqclass = any;

    typesize = atomic;

    { atmop = cas                ? type = (b   )(32, 64); memord = any; s2 = reg, imm }
    { atmop = and, or, xor       ? type = (b   )(32, 64); memord = any; s2 = null     }
    { atmop = add, sub, min, max ? type = (s, u)(32, 64); memord = any; s2 = null     }
    { atmop = wrapinc, wrapdec   ? type = (u   )(32, 64); memord = any; s2 = null     }
    { atmop = st                 ? type = (b   )(32, 64); memord = st;  s2 = null     }
    ;

    s0 = addr.seg;
    s1 = reg, imm;
    s3 = null;
    s4 = null;
}

Inst gcnatomicnoret(Atomic, gcn.atomic.memory, gcn_atomic_noret)

// ============================================================================
// GCN ATOMIC_APPEND, ATOMIC_CONSUME

Req gcn_append_consume
{
    type    = u32;
    segment = gcn;

    d0 = reg;
    s1 = addr.seg;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnappend (Addr, gcn.atomic.memory, gcn_append_consume)
Inst gcnconsume(Addr, gcn.atomic.memory, gcn_append_consume)

// ============================================================================
// GCN Media Operations

Req gcn_msad
{
    type = b32;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req gcn_qsad
{
    type = b64;

    d0 = reg;
    s1 = reg, imm;
    s2 = reg, imm;
    s3 = reg, imm;
    s4 = null;
}

Req gcn_mqsad
{
    type = b64;

    d0 = reg;
    s1 = (reg, imm);
    s2 = (reg, imm).b32;
    s3 = reg;
    s4 = null;
}

Req gcn_mqsad4
{
    type = b32;

    d0 = vec.4;
    s1 = (reg, imm).b64;
    s2 = (reg, imm);
    s3 = vec.4;
    s4 = null;
}

Inst gcnmsad(Basic, gcn.misc, gcn_msad)
Inst gcnsadw(Basic, gcn.misc, gcn_msad)
Inst gcnsadd(Basic, gcn.misc, gcn_msad)

Inst gcnqsad(Basic, gcn.misc, gcn_qsad)

Inst gcnmqsad (Basic, gcn.misc, gcn_mqsad)
Inst gcnmqsad4(Basic, gcn.misc, gcn_mqsad4)

// ============================================================================
// GCN Sleep and Priority

Req gcn_slp_prt
{
    type = u32;

    s0 = reg, imm;
    s1 = null;
    s2 = null;
    s3 = null;
    s4 = null;
}

Inst gcnsleep   (Basic, gcn.misc, gcn_slp_prt)
Inst gcnpriority(Basic, gcn.misc, gcn_slp_prt)

// ============================================================================
// GCN Block Exchange

Req gcn_b4xchg
{
    type = b32;

    d0 = reg;
    s1 = reg;
    s2 = imm;
    s3 = null;
    s4 = null;
}

Inst gcnb4xchg (Basic, gcn.misc, gcn_b4xchg)
Inst gcnb32xchg(Basic, gcn.misc, gcn_b4xchg)


// ============================================================================
//F: add all checks currently implemented in validator
//F: verify that properties which require custom check are specified only once on each path
