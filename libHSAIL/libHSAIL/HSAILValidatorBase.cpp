// University of Illinois/NCSA
// Open Source License
//
// Copyright (c) 2013, Advanced Micro Devices, Inc.
// All rights reserved.
//
// Developed by:
//
//     HSA Team
//
//     Advanced Micro Devices, Inc
//
//     www.amd.com
//
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal with
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
//
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimers.
//
//     * Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimers in the
//       documentation and/or other materials provided with the distribution.
//
//     * Neither the names of the LLVM Team, University of Illinois at
//       Urbana-Champaign, nor the names of its contributors may be used to
//       endorse or promote products derived from this Software without specific
//       prior written permission.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
// SOFTWARE.
//===-- HSAILValidatorBase.cpp - HSAIL Validator Base------------------------------===//

#include "HSAILValidatorBase.h"
#include "HSAILItems.h"
#include "Brig.h"

#include <iosfwd>
#include <sstream>

#include <string.h>

using std::string;
using std::ostringstream;

// ============================================================================
// ============================================================================
//============================================================================
// Instruction Validator

namespace HSAIL_ASM {

//============================================================================
// Autogenerated names of Brig properties

#include "HSAILBrigPropsName_gen.hpp"

//============================================================================

bool PropValidator::isVector(Operand opr, unsigned size)
{
    if (OperandOperandList list = opr)
    {
        unsigned sz = list.elements().size();
        if (sz != size) return false;

        for (unsigned idx = 0; idx < sz; ++idx)
        {
            Operand e = list.elements()[idx];
            if (!OperandRegister(e) && !OperandConstantBytes(e) && !OperandWavesize(e)) return false;
        }

        return true;
    }
    return false;
}

bool PropValidator::isArgList(Operand opr)
{
    if (OperandCodeList list = opr)
    {
        unsigned sz = list.elements().size(); // might be zero

        for (unsigned idx = 0; idx < sz; ++idx)
        {
            DirectiveVariable arg = list.elements()[idx];
            if (!arg) return false;
        }

        return true;
    }
    return false;
}

bool PropValidator::isCallTab(Operand opr)
{
    if (OperandCodeList list = opr)
    {
        unsigned sz = list.elements().size();
        if (sz == 0) return false;

        for (unsigned idx = 0; idx < sz; ++idx)
        {
            DirectiveExecutable f = list.elements()[idx];
            if (!f) return false;
            if (!DirectiveFunction(f) && !DirectiveIndirectFunction(f)) return false;
        }

        return true;
    }
    return false;
}

bool PropValidator::isJumpTab(Operand opr)
{
    if (OperandCodeList list = opr)
    {
        unsigned sz = list.elements().size();
        if (sz == 0) return false;

        for (unsigned idx = 0; idx < sz; ++idx)
        {
            DirectiveLabel lab = list.elements()[idx];
            if (!lab) return false;
        }

        return true;
    }
    return false;
}

const char* PropValidator::operand2str(unsigned valId)
{
    switch(valId)
    {
    case OPERAND_VAL_NULL:      return "none";

    case OPERAND_VAL_REG:       return "a register";
    case OPERAND_VAL_VEC_2:     return "a vector of 2 registers";
    case OPERAND_VAL_VEC_3:     return "a vector of 3 registers";
    case OPERAND_VAL_VEC_4:     return "a vector of 4 registers";

    case OPERAND_VAL_IMM:       return "an immediate or wavesize"; // NB: wavesize may be rejected later by attr checks
    case OPERAND_VAL_CNST:      return "an immediate";
    case OPERAND_VAL_LAB:       return "a label";
    case OPERAND_VAL_ADDR:      return "an address";
    case OPERAND_VAL_FUNC:      return "a function";
    case OPERAND_VAL_IFUNC:     return "an indirect function";
    case OPERAND_VAL_KERNEL:    return "a kernel";
    case OPERAND_VAL_ARGLIST:   return "a list of arguments";
    case OPERAND_VAL_JUMPTAB:   return "a list of labels";
    case OPERAND_VAL_CALLTAB:   return "a list of functions";
    case OPERAND_VAL_SIGNATURE: return "a signature";
    case OPERAND_VAL_FBARRIER:  return "an fbarrier";

    case OPERAND_VAL_IMM0T2:    return "a 32-bit immediate with value 0, 1 or 2";
    case OPERAND_VAL_IMM0T3:    return "a 32-bit immediate with value 0, 1, 2 or 3";

    default:
        assert(false);
        return "?";
    }
}

const char* PropValidator::operandKind2str(unsigned kind)
{
    using namespace Brig;
    switch(kind)
    {
    case BRIG_KIND_OPERAND_ADDRESS:                 return "Address";
    case BRIG_KIND_OPERAND_REGISTER:                return "Reg";
    case BRIG_KIND_OPERAND_WAVESIZE:                return "Wavesize";
    case BRIG_KIND_OPERAND_CONSTANT_BYTES:          return "Immed";
    case BRIG_KIND_OPERAND_ALIGN:                   return "Align";

    case BRIG_KIND_OPERAND_OPERAND_LIST:            return "Vector";
    case BRIG_KIND_OPERAND_CONSTANT_OPERAND_LIST:   return "Array";
    case BRIG_KIND_OPERAND_CODE_LIST:               return "CodeList";
    case BRIG_KIND_OPERAND_CONSTANT_IMAGE:          return "ImageProps";
    case BRIG_KIND_OPERAND_CONSTANT_SAMPLER:        return "SamplerProps";
    case BRIG_KIND_OPERAND_STRING:                  return "String";
    case BRIG_KIND_OPERAND_CODE_REF:                return "CodeRef";
    default: assert(false);                         return "?";
    }
}


const char* PropValidator::val2str(unsigned prop, unsigned val)
{
    const char* res = 0;

    using namespace Brig;
    switch(prop)
    {
    case PROP_TYPE:
    case PROP_SOURCETYPE:
    case PROP_IMAGETYPE:
    case PROP_COORDTYPE:
    case PROP_SIGNALTYPE:      res = (val == BRIG_TYPE_NONE)?         "none" : type2str(val);                break;
    case PROP_PACK:            res = (val == BRIG_PACK_NONE)?         "none" : pack2str(val);                break;
    case PROP_WIDTH:           res = (val == BRIG_WIDTH_NONE)?        "none" : width2str(val);               break;
    case PROP_MEMORYORDER:     res = (val == BRIG_MEMORY_ORDER_NONE)? "none" : memoryOrder2str(val);         break;

    case PROP_GLOBALSEGMENTMEMORYSCOPE:
    case PROP_GROUPSEGMENTMEMORYSCOPE:
    case PROP_IMAGESEGMENTMEMORYSCOPE:
    case PROP_MEMORYSCOPE:     res = (val == BRIG_MEMORY_SCOPE_NONE)? "none" : (val == BRIG_MEMORY_SCOPE_WORKITEM)? "wi"     : memoryScope2str(val); break;

    case PROP_ROUND:           res = (val == BRIG_ROUND_NONE)?        "none" : (val == BRIG_ROUND_FLOAT_DEFAULT) ? "default" : round2str(val);   break;
    case PROP_SEGMENT:         res = (val == BRIG_SEGMENT_NONE)?      "none" : (val == BRIG_SEGMENT_FLAT)?         "flat"    : segment2str(val); break;
    case PROP_ALIGN:           res = (val == BRIG_ALIGNMENT_NONE)?    "none" : (val == BRIG_ALIGNMENT_1)?          "1"       : align2str(val);   break;

    case PROP_FTZ:             res = val? "ftz"    : "none"; break;
    case PROP_ISCONST:         res = val? "const"  : "none"; break;
    case PROP_ISNONULL:        res = val? "nonull" : "none"; break;

    case PROP_COMPARE:         res = compareOperation2str(val); break;
    case PROP_ATOMICOPERATION: res = atomicOperation2str(val);  break;
    case PROP_SIGNALOPERATION: res = atomicOperation2str(val);  break;
    case PROP_GEOMETRY:        res = imageGeometry2str(val);    break;
    case PROP_IMAGEQUERY:      res = imageQuery2str(val);       break;
    case PROP_SAMPLERQUERY:    res = samplerQuery2str(val);     break;
    case PROP_EQUIVCLASS:      res = "";  break; // no sense printing as any value would be valid

    case PROP_OPCODE:          res = opcode2str(val); break;

    case PROP_D0:
    case PROP_D1:

    case PROP_S0:
    case PROP_S1:
    case PROP_S2:
    case PROP_S3:
    case PROP_S4:              res = operand2str(val); break;

    case PROP_TYPESIZE:  // A special case
    case PROP_STYPESIZE: // A special case
    case PROP_OPERAND:
    default:
        assert(false);
        break;
    }

    assert(res);
    return res;
}

unsigned PropValidator::attr2type(Inst inst, unsigned idx, unsigned attr)
{
    using namespace Brig;
    assert(idx < 5);

    switch(attr)
    {
    case OPERAND_ATTR_DTYPE:    return inst.type();
    case OPERAND_ATTR_STYPE:    return getSrcType(inst);
    case OPERAND_ATTR_CTYPE:    return getCrdType(inst);
    case OPERAND_ATTR_ITYPE:    return getImgType(inst);

    case OPERAND_ATTR_B1:       return BRIG_TYPE_B1;
    case OPERAND_ATTR_B32:      return BRIG_TYPE_B32;
    case OPERAND_ATTR_B64:      return BRIG_TYPE_B64;
    case OPERAND_ATTR_U32:      return BRIG_TYPE_U32;
    case OPERAND_ATTR_U64:      return BRIG_TYPE_U64;
    case OPERAND_ATTR_S32:      return BRIG_TYPE_S32;
    case OPERAND_ATTR_S64:      return BRIG_TYPE_S64;
    case OPERAND_ATTR_SAMP:     return BRIG_TYPE_SAMP;
    case OPERAND_ATTR_SIG32:    return BRIG_TYPE_SIG32;
    case OPERAND_ATTR_SIG64:    return BRIG_TYPE_SIG64;
    case OPERAND_ATTR_P2U:      return packedType2uType(inst.type());

    default:
        assert(false);
        return BRIG_TYPE_NONE;
    }
}

// Used mostly for diagnostic messages
string PropValidator::prop2str(unsigned prop)
{
    switch(prop)
    {
    case PROP_OPCODE:          return "opcode";
    case PROP_TYPE:            return "type";
    case PROP_SOURCETYPE:      return "src type";
    case PROP_IMAGETYPE:       return "image type";
    case PROP_COORDTYPE:       return "coord type";
    case PROP_SIGNALTYPE:      return "signal type";

    case PROP_PACK:            return "packing";
    case PROP_COMPARE:         return "comparison operator";
    case PROP_ROUND:           return "rounding";
    case PROP_FTZ:             return "modifier"; // output looks like this: "invalid modifier (ftz), expected: none"
    case PROP_ISCONST:         return "modifier"; // output looks like this: "invalid modifier (const), expected: none"
    case PROP_ISNONULL:        return "modifier"; // output looks like this: "invalid modifier (nonull), expected: none"
    case PROP_ALIGN:           return "align";
    case PROP_ATOMICOPERATION: return "atomic operation";
    case PROP_SIGNALOPERATION: return "signal operation";
    case PROP_MEMORYORDER:     return "memory order";

    case PROP_GLOBALSEGMENTMEMORYSCOPE: return "global segment memory scope";
    case PROP_GROUPSEGMENTMEMORYSCOPE:  return "group segment memory scope";
    case PROP_IMAGESEGMENTMEMORYSCOPE:  return "image segment memory scope";
    case PROP_MEMORYSCOPE:              return "memory scope";

    case PROP_GEOMETRY:        return "geom";
    case PROP_IMAGEQUERY:      return "image query";
    case PROP_SAMPLERQUERY:    return "sampler query";
    case PROP_SEGMENT:         return "segment";
    case PROP_WIDTH:           return "width";
    case PROP_EQUIVCLASS:      return "equivalence class";

    case PROP_D0:              return "operand 0";
    case PROP_D1:              return "operand 1";

    case PROP_S0:              return "operand 0";
    case PROP_S1:              return "operand 1";
    case PROP_S2:              return "operand 2";
    case PROP_S3:              return "operand 3";
    case PROP_S4:              return "operand 4";

    case PROP_TYPESIZE:  // A special case
    case PROP_STYPESIZE: // A special case
    case PROP_OPERAND:
    default:
        assert(false);
        return "";
    }
}

// Used by TestGen for test tagging (key=value)
const char* PropValidator::prop2key(unsigned prop)
{
    switch(prop)
    {
    case PROP_FTZ:         return "modifier";      // output looks like this: "modifier=ftz"
    case PROP_ISCONST:     return "modifier";      // output looks like this: "modifier=const"
    case PROP_ISNONULL:    return "modifier";      // output looks like this: "modifier=nonull"

    case PROP_D0:          return "operand 0";
    case PROP_D1:          return "operand 1";

    case PROP_S0:          return "operand 0";
    case PROP_S1:          return "operand 1";
    case PROP_S2:          return "operand 2";
    case PROP_S3:          return "operand 3";
    case PROP_S4:          return "operand 4";

    case PROP_TYPESIZE:  // A special case
    case PROP_STYPESIZE: // A special case
    case PROP_OPERAND:
        assert(false);
        return "";

    default: return getBrigPropName(prop);
    }
};

void PropValidator::invalidFormat(Inst inst, const char* msg)
{
    validate(inst, false, "Invalid instruction format, expected " + string(msg));
}

void PropValidator::brigPropError(Inst inst, unsigned prop, unsigned value, unsigned* vals, unsigned length)
{
    propError(inst, prop, val2str(prop, value), vals, length);
}

void PropValidator::propError(Inst inst, unsigned prop, string value, unsigned* vals, unsigned length)
{
    assert(inst);
    assert(vals && length > 0);
    assert(PROP_MINID < prop && prop < PROP_MAXID);
    assert(prop != PROP_TYPESIZE && prop != PROP_STYPESIZE); // metaproperties are special

    string s = val2str(prop, vals[0]);
    for (unsigned i = 1; i < length; ++i) s = s + ", " + val2str(prop, vals[i]);

    unsigned operandIdx = getOperandIdx(prop);
    string expected = (length == 1)? ", expected: " : ", expected one of: ";

    if (operandIdx <= 4) // operand property
    {
        if (!inst.operand(operandIdx))
        {
            validate(inst, operandIdx, false, "Missing " + prop2str(prop) + expected + s);
        }
        else
        {
            validate(inst, operandIdx, false, "Invalid " + prop2str(prop) + expected + s);
        }
    }
    else // non-operand property
    {
        if (value.length() > 0) value = " (" + value + ")";
        validate(inst, false, "Instruction has invalid " + prop2str(prop) + value + expected + s);
    }
}

bool PropValidator::validateTypeSz(Inst inst, unsigned propVal, unsigned type, const char* typeName, bool isAssert /*=true*/)
{
    assert(inst);

    switch (propVal)
    {
    case TYPESIZE_VAL_SEG:
        if ((unsigned)getBrigTypeNumBits(type) == getSegAddrSize(HSAIL_ASM::getSegment(inst), isLargeModel())) return true;
        if (isAssert) validate(inst, false, string(typeName) + " must match segment kind and machine model");
        break;

    case TYPESIZE_VAL_MODEL:
        return validateInstTypeSize(inst, type, typeName, isAssert);

    case TYPESIZE_VAL_SIGNAL:
        if (type == Brig::BRIG_TYPE_SIG64 && isLargeModel())  return true;
        if (type == Brig::BRIG_TYPE_SIG32 && !isLargeModel()) return true;
        if (isAssert) validate(inst, false, "Instruction type must match machine model");
        break;

    case TYPESIZE_VAL_ATOMIC:
        return validateAtomicTypeSize(inst, isAssert);

    default:
        assert(false);
        break;
    }
    return false;
}

bool PropValidator::validateTypesize(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(length == 1);
    assert(attr == TYPESIZE_ATTR_NONE);

    return validateTypeSz(inst, vals[0], inst.type(), "Instruction type", isAssert);
}

bool PropValidator::validateStypesize(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(length == 1);
    assert(attr == STYPESIZE_ATTR_NONE);

    return validateTypeSz(inst, vals[0], getSrcType(inst), "Source type", isAssert);
}

bool PropValidator::validateOperandAttr(Inst inst, unsigned operandIdx, unsigned attr, bool isDst, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);
    assert(ATTR_MINID < attr && attr < ATTR_MAXID);
    assert(inst.operand(operandIdx));

    switch (attr)
    {
    case OPERAND_ATTR_DTYPE:
    case OPERAND_ATTR_STYPE:
    case OPERAND_ATTR_CTYPE:
    case OPERAND_ATTR_B1:
    case OPERAND_ATTR_B32:
    case OPERAND_ATTR_B64:
    case OPERAND_ATTR_U32:
    case OPERAND_ATTR_U64:
    case OPERAND_ATTR_S32:
    case OPERAND_ATTR_S64:
    case OPERAND_ATTR_SAMP:
    case OPERAND_ATTR_SIG32:
    case OPERAND_ATTR_SIG64:
    case OPERAND_ATTR_ITYPE:
    case OPERAND_ATTR_P2U:    return validateOperandType(inst, operandIdx, isDst, attr, isAssert);

    case OPERAND_ATTR_SEG:    return checkAddrSeg(inst, operandIdx, isAssert);
    case OPERAND_ATTR_TSEG:   return checkAddrTSeg(inst, operandIdx, isAssert);

    default:
        assert(false);
        return false;
    }
}

// 1) address size must match _instruction_ segment size;
// 2) if inst.segment=flat, address must be flat
// 3) addresses in arg and spill segments must include a symbol
// 4) if address includes a symbol, symbol.segment must be the same as instr.segment
bool PropValidator::checkAddrSeg(Inst inst, unsigned operandIdx, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);

    OperandAddress opr = inst.operand(operandIdx);
    assert(opr);

    if (HSAIL_ASM::getSegment(inst) == Brig::BRIG_SEGMENT_FLAT && opr.symbol())
    {
        if (isAssert) validate(inst, operandIdx, false, "Address segment does not match instruction segment (expected flat address)");
        return false;
    }

    if (opr.symbol() && opr.symbol().segment() != HSAIL_ASM::getSegment(inst))
    {
        if (isAssert) validate(inst, operandIdx, false, "Address segment does not match instruction segment");
        return false;
    }

    if (!opr.symbol() && !isAddressableSeg(HSAIL_ASM::getSegment(inst)))
    {
        if (isAssert) validate(inst, operandIdx, false, "Flat address cannot be used with arg and spill segments");
        return false;
    }

    unsigned addrSize = getAddrSize(opr, isLargeModel()); // 32 or 64; 0 if both are valid
    unsigned segAddrSize = getSegAddrSize(HSAIL_ASM::getSegment(inst), isLargeModel());
    if (addrSize != 0 && addrSize != segAddrSize)
    {
        if (isAssert) validate(inst, operandIdx, false, "Address size does not match instruction type");
        return false;
    }

    if (segAddrSize == 32 && opr.offset().hi() != 0)
    {
        if (isAssert) validate(inst, operandIdx, false, "32-bit OperandAddress must have zero offset.hi");
        return false;
    }

    return true;
}

// 1+2+3+4
// 5) opaque symbols used in address must match instruction type
bool PropValidator::checkAddrTSeg(Inst inst, unsigned operandIdx, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);

    if (!checkAddrSeg(inst, operandIdx, isAssert)) return false;

    OperandAddress opr = inst.operand(operandIdx);
    assert(opr);

    if (!opr.symbol()) return true;

    unsigned type = inst.type();
    unsigned otype = opr.symbol().elementType();

    if (type == otype) return true;

    if (isOpaqueType(type))
    {
        if (isAssert) validate(inst, operandIdx, false, "Instruction type does not match address symbol type");
        return false;
    }

    if (isOpaqueType(otype))
    {
        if (isAssert) validate(inst, operandIdx, false, "Opaque symbol used in address does not match instruction type");
        return false;
    }

    return true;
}

bool PropValidator::isImm(Operand opr)
{
    if (OperandConstantBytes imm = opr)
    {
        unsigned sz = getImmSize(imm);
        if (0 < sz && sz <= 128) return true;
    }
    return false;
}

bool PropValidator::isImmInRange(Operand opr, unsigned low, unsigned high)
{
    if (OperandConstantBytes imm = opr)
    {
        if (getImmSize(imm) != 32) return false;

        unsigned val = getImmAsU32(imm);
        return low <= val && val <= high;
    }
    return false;
}

bool PropValidator::checkOperandKind(Inst inst, unsigned operandIdx, unsigned* vals, unsigned length, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);
    assert(vals && length > 0);

    using namespace Brig;

    Operand opr = inst.operand(operandIdx);

    for (unsigned i = 0; i < length; ++i)
    {
        switch(vals[i])
        {
        case OPERAND_VAL_NULL:      if (!opr) return true; break;

        case OPERAND_VAL_ADDR:      if (OperandAddress(opr))                                    return true; break;
        case OPERAND_VAL_LAB:       if (isCodeRef(opr, BRIG_KIND_DIRECTIVE_LABEL))              return true; break;
        case OPERAND_VAL_FUNC:      if (isCodeRef(opr, BRIG_KIND_DIRECTIVE_FUNCTION) ||
                                        isCodeRef(opr, BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION))  return true; break;
        case OPERAND_VAL_IFUNC:     if (isCodeRef(opr, BRIG_KIND_DIRECTIVE_INDIRECT_FUNCTION))  return true; break;
        case OPERAND_VAL_KERNEL:    if (isCodeRef(opr, BRIG_KIND_DIRECTIVE_KERNEL))             return true; break;
        case OPERAND_VAL_SIGNATURE: if (isCodeRef(opr, BRIG_KIND_DIRECTIVE_SIGNATURE))          return true; break;
        case OPERAND_VAL_FBARRIER:  if (isCodeRef(opr, BRIG_KIND_DIRECTIVE_FBARRIER))           return true; break;
        case OPERAND_VAL_ARGLIST:   if (isArgList(opr))                                         return true; break;
        case OPERAND_VAL_CALLTAB:   if (isCallTab(opr))                                         return true; break;
        case OPERAND_VAL_JUMPTAB:   if (isJumpTab(opr))                                         return true; break;

        case OPERAND_VAL_IMM:       if (isImm(opr) || OperandWavesize(opr))                     return true; break;
        case OPERAND_VAL_CNST:      if (isImm(opr))                                             return true; break;
        case OPERAND_VAL_IMM0T2:    if (isImmInRange(opr, 0, 2))                                return true; break;
        case OPERAND_VAL_IMM0T3:    if (isImmInRange(opr, 0, 3))                                return true; break;

        case OPERAND_VAL_REG:       if (OperandRegister(opr))                                   return true; break;
        case OPERAND_VAL_VEC_2:     if (isVector(opr, 2))                                       return true; break;
        case OPERAND_VAL_VEC_3:     if (isVector(opr, 3))                                       return true; break;
        case OPERAND_VAL_VEC_4:     if (isVector(opr, 4))                                       return true; break;

        default:
            assert(false);
            break;
        }
    }

    return false;
}

bool PropValidator::validateOperand(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(inst);
    assert(vals && length > 0);
    assert(PROP_MINID < prop && prop < PROP_MAXID);
    assert(ATTR_MINID < attr && attr < ATTR_MAXID);

    bool isDst = (prop == PROP_D0 || prop == PROP_D1);
    unsigned oprIdx = getOperandIdx(prop);
    assert(oprIdx <= 4);

    if (!checkOperandKind(inst, oprIdx, vals, length, isAssert))
    {
        if (isAssert) propError(inst, prop, "", vals, length); // FIXME: decode 'val'
        return false;
    }

    OperandOperandList vec = inst.operand(oprIdx);
    if (isDst && vec && !validateDstVector(inst, vec, oprIdx, isAssert)) return false;

    if (attr != OPERAND_ATTR_NONE)
    {
        return validateOperandAttr(inst, oprIdx, attr, isDst, isAssert);
    }
    return true;
}

bool PropValidator::validateEqclass(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(prop == PROP_EQUIVCLASS);
    assert(attr == EQCLASS_ATTR_NONE);
    assert(length == 1);

    if (vals[0] == EQCLASS_VAL_ANY)
    {
        return true;
    }
    else if (vals[0] == EQCLASS_VAL_0)
    {
        if (getEqClass(inst) == 0) return true;
        if (isAssert)
        {
            ostringstream s;
            s << "Instruction has invalid equivClass " << getEqClass(inst) << ", expected: 0";
            validate(inst, false, s.str());
        }
        return false;
    }
    else
    {
        assert(false);
        return false;
    }

}

bool PropValidator::validateRound(Inst inst, unsigned prop, unsigned val, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(prop == PROP_ROUND);
    assert(length > 0);

    return validateSpecialProp(inst, prop, val, vals, length, isAssert);
}

bool PropValidator::validateFtz(Inst inst, unsigned prop, unsigned val, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(prop == PROP_FTZ);
    assert(val == 0 || val == 1);
    assert(length == 1 || length == 2);

    return validateSpecialProp(inst, prop, val, vals, length, isAssert);
}

bool PropValidator::validateSpecialProp(Inst inst, unsigned prop, unsigned val, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(inst);

    const char* msg = validateProp(prop, val, vals, length, mModel, mProfile);
    if (msg)
    {
        if (isAssert) validate(inst, !msg, SRef(msg));
        return false;
    }

    for (unsigned i = 0; i < length; ++i)
    {
        if (vals[i] == val) return true;
    }

    if (isAssert) brigPropError(inst, prop, val, vals, length);
    return false;
}

void PropValidator::invalidVariant(Inst inst, unsigned prop)
{
    validate(inst, false, "Instruction has invalid " + prop2str(prop));
}

void PropValidator::invalidVariant(Inst inst, unsigned prop1, unsigned prop2)
{
    validate(inst, false, "Instruction has invalid combination of " + prop2str(prop1) + " and " + prop2str(prop2));
}

void PropValidator::invalidVariant(Inst inst, unsigned prop1, unsigned prop2, unsigned prop3)
{
    validate(inst, false, "Instruction has invalid combination of " + prop2str(prop1) + " and " + prop2str(prop2) + " and " + prop2str(prop3));
}

//-----------------------------------------------------------------------------

static string getOperandTypeName(unsigned attr)
{
    switch(attr)
    {
    case OPERAND_ATTR_DTYPE:    return "operation";
    case OPERAND_ATTR_STYPE:    return "source";
    case OPERAND_ATTR_CTYPE:    return "coord";
    default:                    return ""; // operand has fixed type
    }
}

static string getExpectedTypeName(unsigned type)
{
    return "(" + string(type2str(type)) + ")";
}

string PropValidator::getErrHeader(unsigned oprIdx, const char* oprPref)
{
    assert(oprIdx <= 4);
    return string(oprPref) + " " + static_cast<char>('0' + oprIdx);
}

void PropValidator::operandError(Inst inst, unsigned oprIdx, string msg1, string msg2 /*=""*/)
{
    assert(oprIdx <= 4);

    string errHdr = getErrHeader(oprIdx, "Operand");
    validate(inst, oprIdx, false, errHdr + " " + msg1 + msg2);
}

void PropValidator::operandSizeError(Inst inst, unsigned oprIdx, unsigned type, unsigned attr)
{
    assert(inst);
    assert(oprIdx <= 4);

    string err = getOperandTypeName(attr);
    if (!err.empty()) // empty if operand has fixed type, otherwise "operation", "source", etc
    {
        operandError(inst, oprIdx, "size does not match ", err + ((attr == OPERAND_ATTR_DTYPE)? " size" : " type size"));
        return;
    }

    Operand opr = inst.operand(oprIdx);
    string errHdr = getErrHeader(oprIdx, "Invalid operand");

    string errMsg = "";
    if (OperandConstantBytes(opr) || OperandOperandList(opr))
    {
        switch(getBrigTypeNumBits(type))
        {
        case 1:   errMsg = "an 1-bit";  break;
        case 8:   errMsg = "a 8-bit";   break;
        case 16:  errMsg = "a 16-bit";  break;
        case 32:  errMsg = "a 32-bit";  break;
        case 64:  errMsg = "a 64-bit";  break;
        case 128: errMsg = "a 128-bit"; break;
        default:
            assert(false);
            break;
        }
        errMsg += OperandConstantBytes(opr)? " immediate" : " vector";
    }
    else if (OperandRegister(opr))
    {
        switch(getBrigTypeNumBits(type))
        {
        case 1:   errMsg = "a 'c' register";  break;
        case 32:  errMsg = "an 's' register"; break;
        case 64:  errMsg = "a 'd' register";  break;
        case 128: errMsg = "a 'q' register";  break;
        default:
            assert(false);
            break;
        }
    }
    else
    {
        assert(false);
    }

    validate(inst, oprIdx, false, errHdr + " size: expected " + errMsg);
}

void PropValidator::immTypeError(Inst inst, unsigned oprIdx, unsigned type, unsigned expectedType, bool isB1Error)
{
    assert(inst);
    assert(oprIdx <= 4);

    string brigType;
    if (type != expectedType)
    {
        brigType = string("( ") + type2str(expectedType) + " in BRIG)";
    }

    if (isB1Error)
    {
        assert(OperandConstantBytes(inst.operand(oprIdx))); // cannot be a vector

        string errHdr = getErrHeader(oprIdx, "Invalid value of immediate operand");
        validate(inst, oprIdx, false, errHdr + ": expected 0 or 1");
    }
    else if (OperandOperandList(inst.operand(oprIdx)))
    {
        string errHdr = getErrHeader(oprIdx, "Vector operand");
        validate(inst, oprIdx, false, errHdr + " has invalid type of immediate value; expected " + type2str(type) + brigType);
    }
    else
    {
        string errHdr = getErrHeader(oprIdx, "Invalid type of immediate operand");
        validate(inst, oprIdx, false, errHdr + ": expected " + type2str(type) + brigType);
    }
}

void PropValidator::wavesizeError(Inst inst, unsigned oprIdx, unsigned type, unsigned attr)
{
    assert(inst);
    assert(oprIdx <= 4);

    Operand opr = inst.operand(oprIdx);

    assert(OperandWavesize(opr) || OperandOperandList(opr));

    string typeInfo = getOperandTypeName(attr); // empty if operand has fixed type, otherwise "operation", "source", etc
    typeInfo += typeInfo.empty()? ("expected operand type " + getExpectedTypeName(type)) : " type";
    string operandInfo = OperandWavesize(opr)? "cannot be" : "cannot include";
    operandError(inst, oprIdx, operandInfo + " wavesize: incompatible with ", typeInfo);
}

bool PropValidator::validateOperandVector(Inst inst, OperandOperandList opr, unsigned oprIdx, unsigned type, unsigned attr, bool isAssert)
{
    unsigned size = opr.elements().size();
    for (unsigned i = 0; i < size; ++i)
    {
        Operand elem = opr.elements()[i];

        if (OperandRegister x = elem)
        {
            if (!validateOperandReg(inst, x, oprIdx, type, attr, isAssert)) return false;
        }
        else if (OperandConstantBytes x = elem)
        {
            if (!validateOperandImmed(inst, x, oprIdx, type, attr, isAssert)) return false;
        }
        else if (OperandWavesize(elem))
        {
            if (!validateOperandWavesize(inst, oprIdx, type, attr, isAssert)) return false;
        }
        else
        {
            assert(false); // validated by 'isVector'
            return false;
        }
    }
    return true;
}

bool PropValidator::validateOperandReg(Inst inst, OperandRegister opr, unsigned oprIdx, unsigned type, unsigned attr, bool isAssert)
{
    assert(opr == inst.operand(oprIdx) || OperandOperandList(inst.operand(oprIdx)));

    unsigned iSize = getBrigTypeNumBits(type);
    bool isSubWord = (iSize == 8) || (iSize == 16);

    unsigned oSize = getRegBits(opr.regKind());
    if (iSize == oSize || (isSubWord && oSize == 32)) return true;
    if (isAssert) operandSizeError(inst, oprIdx, type, attr);
    return false;
}

bool PropValidator::validateOperandImmed(Inst inst, OperandConstantBytes opr, unsigned oprIdx, unsigned type, unsigned attr, bool isAssert)
{
    assert(opr == inst.operand(oprIdx) || OperandOperandList(inst.operand(oprIdx)));

    using namespace Brig;

    bool b1Error = (type == BRIG_TYPE_B1 && !isImmB1(opr));
    unsigned expectedType = isBitType(type)? bitType2uType(type) : type;

    if (expectedType == opr.type() && !b1Error) return true;
    if (isAssert) immTypeError(inst, oprIdx, type, expectedType, b1Error);
    return false;

    //F1.0 Make sure image and sampler initializers are not allowed as operands

    //F1.0
    ///unsigned iSize = getBrigTypeNumBits(type);
    ///unsigned oSize = getImmSize(opr);
    ///
    ///if (iSize == oSize) return true;
    ///if (iSize == 1 && oSize == 8)
    ///{
    ///    if (isImmB1(opr)) return true;
    ///    if (isAssert) operandSizeError(inst, oprIdx, type, attr);
    ///    return false;
    ///}
    ///if (isAssert) operandSizeError(inst, oprIdx, type, attr);
    ///return false;
}

bool PropValidator::validateOperandWavesize(Inst inst, unsigned oprIdx, unsigned type, unsigned attr, bool isAssert)
{
    assert(OperandWavesize(inst.operand(oprIdx)) || OperandOperandList(inst.operand(oprIdx)));

    if (isIntType(type) && type != Brig::BRIG_TYPE_B128) return true;
    if (isAssert) wavesizeError(inst, oprIdx, type, attr);
    return false;
}

bool PropValidator::validateOperandType(Inst inst, unsigned oprIdx, bool isDst, unsigned attr, bool isAssert)
{
    assert(inst);
    assert(oprIdx <= 4);
    using namespace Brig;

    Operand opr   = inst.operand(oprIdx);
    unsigned type = attr2type(inst, oprIdx, attr);

    if (!opr)
    {
        if (isAssert) operandError(inst, oprIdx, "is missing");
        return false;
    }

    if (isDst && !OperandRegister(opr) && !OperandOperandList(opr))
    {
        if (isAssert) operandError(inst, oprIdx, "must be a register or a vector");
        return false;
    }

    if (OperandRegister(opr))
    {
        return validateOperandReg(inst, opr, oprIdx, type, attr, isAssert);
    }
    else if (OperandOperandList(opr))
    {
        return validateOperandVector(inst, opr, oprIdx, type, attr, isAssert);
    }
    else if (OperandConstantBytes(opr))
    {
        return validateOperandImmed(inst, opr, oprIdx, type, attr, isAssert);
    }
    else if (OperandWavesize(opr))
    {
        return validateOperandWavesize(inst, oprIdx, type, attr, isAssert);
    }
    else
    {
        return true; // nothing to check
    }
}

bool PropValidator::validateDstVector(Inst inst, OperandOperandList vector, unsigned oprIdx, bool isAssert)
{
    assert(vector);
    unsigned size = vector.elements().size();
    assert(2 <= size && size <= 4);

    for (unsigned i = 0; i < size; ++i) // Check that all registers in destination vector are unique
    {
        if (OperandRegister ri = vector.elements()[i])
        {
            for (unsigned j = i + 1; j < size; ++j)
            {
                if (OperandRegister rj = vector.elements()[j])
                {
                    if (ri.regNum() == rj.regNum())
                    {
                        if (isAssert) validate(inst, oprIdx, false, "Destination vector operand must not include the same register more than once");
                        return false;
                    }
                }
            }
        }
        else
        {
            if (isAssert) validate(inst, oprIdx, false, "Destination vector operand must not include immediate values or wavesize");
            return false;
        }
    }
    return true;
}

bool PropValidator::validateAtomicTypeSize(Inst inst, bool isAssert)
{
    assert(inst);

    // \todo 1.0p: temporarily removed restriction on 64-bit atomics in 32-bit mode
    // if (getBrigTypeNumBits(inst.type()) == 64 && !isLargeModel())
    // {
    //     if (isAssert) validate(inst, -1, false, "Instruction type size 64 is not allowed with small machine model");
    //     return false;
    // }
    return true;
}

bool PropValidator::validateInstTypeSize(Inst inst, unsigned type, const char* typeName, bool isAssert)
{
    assert(inst);

    unsigned typeSize = getMachineSize();

    if (getBrigTypeNumBits(type) != typeSize)
    {
        if (isAssert) validate(inst, -1, false, string(typeName) + " size must match machine model");
        return false;
    }
    return true;
}

//-----------------------------------------------------------------------------

} // namespace HSAIL_ASM
