// University of Illinois/NCSA
// Open Source License
// 
// Copyright (c) 2013, Advanced Micro Devices, Inc.
// All rights reserved.
// 
// Developed by:
// 
//     HSA Team
// 
//     Advanced Micro Devices, Inc
// 
//     www.amd.com
// 
// Permission is hereby granted, free of charge, to any person obtaining a copy of
// this software and associated documentation files (the "Software"), to deal with
// the Software without restriction, including without limitation the rights to
// use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
// of the Software, and to permit persons to whom the Software is furnished to do
// so, subject to the following conditions:
// 
//     * Redistributions of source code must retain the above copyright notice,
//       this list of conditions and the following disclaimers.
// 
//     * Redistributions in binary form must reproduce the above copyright notice,
//       this list of conditions and the following disclaimers in the
//       documentation and/or other materials provided with the distribution.
// 
//     * Neither the names of the LLVM Team, University of Illinois at
//       Urbana-Champaign, nor the names of its contributors may be used to
//       endorse or promote products derived from this Software without specific
//       prior written permission.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
// FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
// CONTRIBUTORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS WITH THE
// SOFTWARE.
//===-- HSAILValidatorBase.cpp - HSAIL Validator Base------------------------------===//

#include "HSAILValidatorBase.h"
#include "HSAILItems.h"
#include "Brig.h"

#include <iostream>
#include <sstream>

#include <string.h>

using std::string;
using std::ostringstream;

// ============================================================================
// ============================================================================
//============================================================================
// Instruction Validator

namespace HSAIL_ASM {

//============================================================================
// Autogenerated names of Brig properties

#include "HSAILBrigPropsName_gen.hpp"

//============================================================================

bool PropValidator::isImage(Operand opr, bool isRW /*=false*/)
{
    OperandAddress addr = opr;
    if (addr) {
        DirectiveVariable var = addr.symbol();
        return var && var.type()==(isRW? Brig::BRIG_TYPE_RWIMG : Brig::BRIG_TYPE_ROIMG);
    }
    return false;
}

bool PropValidator::isSampler(Operand opr)
{
    OperandAddress addr = opr;
    if (addr) {
        DirectiveVariable var = addr.symbol();
        return var && var.type()==Brig::BRIG_TYPE_SAMP;
    }
    return false;
}

bool PropValidator::isJumpTab(Inst inst, unsigned operandIdx, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);

    Operand opr = inst.operand(operandIdx);
    // NB: opr might be null!

    // NB: 'isAssert' and 'validate' should be used with great care!
    // - even it isAssert=true, this call is only a probe (there may be several variants for an operand)
    // - use 'validate' only if operand looks like a list of jump targets
    // - use 'validate' only to improve errors reporting

    using namespace Brig;

    if (OperandLabelVariableRef ref = opr)
    {
        unsigned utype = isLargeModel()? BRIG_TYPE_U64 : BRIG_TYPE_U32;

        if (DirectiveVariable sym = ref.ref())
        {
            if (!sym.modifier().isArray())
            {
                if (isAssert) validate(inst, operandIdx, false, "Invalid descriprion of jump targets; expected a reference to an array initialized with labels");
                return false;
            }
            if (sym.modifier().isDeclaration())
            {
                if (isAssert) validate(inst, operandIdx, false, "Invalid descriprion of jump targets; expected a reference to an array definition");
                return false;
            }
            if (sym.dim() == 0 || sym.modifier().isFlexArray())
            {
                if (isAssert) validate(inst, operandIdx, false, "Invalid descriprion of jump targets; expected a reference to a non-empty array initialized with labels");
                return false;
            }
            if (sym.type() != BRIG_TYPE_U64 && sym.type() != BRIG_TYPE_U32)
            {
                if (isAssert) validate(inst, operandIdx, false, "Array of labels must have type u32 or u64");
                return false;
            }
            if (sym.type() != utype)
            {
                if (isAssert) validate(inst, operandIdx, false, "Array type does not match machine model");
                return false;
            }

            DirectiveLabelInit list = sym.init();
            if (!list)
            {
                if (isAssert) validate(inst, operandIdx, false, "Invalid descriprion of jump targets; expected a reference to an array initialized with labels");
                return false;
            }

            if (list.elementCount() == 0)
            {
                if (isAssert) validate(inst, operandIdx, false, "Invalid descriprion of jump targets; expected a reference to a non-empty array initialized with labels");
                return false;
            }
        }
        else
        {
            if (isAssert) validate(inst, operandIdx, false, "Invalid descriprion of jump targets; expected a reference to an array initialized with labels");
            return false;
        }
    }
    else if (OperandLabelTargetsRef labref = opr)
    {
        DirectiveLabelTargets list = labref.ref();

        if (!list)
        {
            if (isAssert) validate(inst, operandIdx, false, "Invalid reference to labeltargets statement");
            return false;
        }

        if (list.elementCount() == 0)
        {
            if (isAssert) validate(inst, operandIdx, false, "Invalid labeltargets statement; must include at least one label");
            return false;
        }
    }
    else
    {
        return false;
    }
    return true;
}

bool PropValidator::isCallTab(Inst inst, unsigned operandIdx, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);

    Operand opr = inst.operand(operandIdx);
    // opr might be null!

    // NB: 'isAssert' and 'validate' should be used with great care!
    // - even it isAssert=true, this call is only a probe (there may be several variants for an operand)
    // - use 'validate' only if operand looks like a list of call targets
    // - use 'validate' only to improve errors reporting

    using namespace Brig;

    if (OperandFunctionList list = opr)
    {
        if (list.elementCount() == 0) return false;
    }
    else if (OperandSignatureRef ref = opr)
    {
        DirectiveSignature signature = ref.ref();
        if (!signature) return false;
    }
    else
    {
        return false;
    }
    return true;
}

const char* PropValidator::operand2str(unsigned valId)
{
    switch(valId)
    {
    case OPERAND_VAL_NULL:      return "null";

    case OPERAND_VAL_REG:       return "a register";
    case OPERAND_VAL_REG_V2:    return "a vector of 2 registers";
    case OPERAND_VAL_REG_V3:    return "a vector of 3 registers";
    case OPERAND_VAL_REG_V4:    return "a vector of 4 registers";

    case OPERAND_VAL_IMM:       return "an immediate or wavesize"; // NB: wavesize may be rejected later by attr checks
    case OPERAND_VAL_LAB:       return "a label";
    case OPERAND_VAL_ADDR:      return "an address";
    case OPERAND_VAL_FUNC:      return "a function";
    case OPERAND_VAL_ARGLIST:   return "a list of arguments";
    case OPERAND_VAL_JUMPTAB:   return "a list of jump targets";
    case OPERAND_VAL_CALLTAB:   return "a list of call targets";
    case OPERAND_VAL_FBARRIER:  return "an fbarrier";

    case OPERAND_VAL_ROIMAGE:   return "a read-only image";
    case OPERAND_VAL_RWIMAGE:   return "a read-write image";
    case OPERAND_VAL_SAMPLER:   return "a sampler";

    case OPERAND_VAL_IMM0T2:    return "a 32-bit immediate with value 0, 1 or 2";
    case OPERAND_VAL_IMM0T3:    return "a 32-bit immediate with value 0, 1, 2 or 3";

    default:
        assert(false);
        return "?";
    }
}

const char* PropValidator::operandKind2str(unsigned kind) {
    using namespace Brig;
    switch(kind) {
    case BRIG_OPERAND_ADDRESS:            return "Address";         
    case BRIG_OPERAND_ARGUMENT_LIST:      return "ArgumentList";    
    case BRIG_OPERAND_FBARRIER_REF:       return "FbarrierRef";     
    case BRIG_OPERAND_FUNCTION_LIST:      return "FunctionList";    
    case BRIG_OPERAND_FUNCTION_REF:       return "FunctionRef";     
    case BRIG_OPERAND_IMMED:              return "Immed";           
    case BRIG_OPERAND_LABEL_REF:          return "LabelRef";        
    case BRIG_OPERAND_REG:                return "Reg";             
    case BRIG_OPERAND_REG_VECTOR:         return "RegVector";       
    case BRIG_OPERAND_SIGNATURE_REF:      return "SignatureRef";    
    case BRIG_OPERAND_LABEL_TARGETS_REF:  return "LabelTargetsRef"; 
    case BRIG_OPERAND_LABEL_VARIABLE_REF: return "LabelVariableRef";
    case BRIG_OPERAND_WAVESIZE:           return "Wavesize";        
    default: assert(false);               return "?";
    }
}

const char* PropValidator::val2str(unsigned prop, unsigned val)
{
    const char* res = 0;

    using namespace Brig;
    switch(prop)
    {
    case PROP_TYPE:
    case PROP_SOURCETYPE:
    case PROP_IMAGETYPE:
    case PROP_COORDTYPE:
    case PROP_SIGNALTYPE:      res = (val == BRIG_TYPE_NONE)?         "none" : typeX2str(val);          break;
    case PROP_PACK:            res = (val == BRIG_PACK_NONE)?         "none" : pack2str(val);           break;
    case PROP_ROUND:           res = (val == BRIG_ROUND_NONE)?        "none" : round2str(val);          break;
    case PROP_WIDTH:           res = (val == BRIG_WIDTH_NONE)?        "none" : width2str(val);          break;
    case PROP_SEGMENTS:        res = (val == BRIG_MEMORY_FENCE_NONE)? "none" : memoryFenceSeg2str(val); break; 
    case PROP_MEMORYORDER:     res = (val == BRIG_MEMORY_ORDER_NONE)? "none" : memoryOrder2str(val);    break;
    case PROP_MEMORYSCOPE:     res = (val == BRIG_MEMORY_SCOPE_NONE)? "none" : memoryScope2str(val);    break;
    case PROP_SEGMENT:         res = (val == BRIG_SEGMENT_NONE)?      "none" : (val == BRIG_SEGMENT_FLAT)? "flat" : segment2str(val); break;
    case PROP_ALIGN:           res = (val == BRIG_ALIGNMENT_NONE)?    "none" : (val == BRIG_ALIGNMENT_1)?  "1"    : align2str(val);   break;
                               
    case PROP_FTZ:             res = val? "ftz"    : "none"; break;
    case PROP_ISCONST:         res = val? "const"  : "none"; break;
    case PROP_ISNONULL:        res = val? "nonull" : "none"; break;
                               
    case PROP_COMPARE:         res = compareOperation2str(val); break;
    case PROP_ATOMICOPERATION: res = atomicOperation2str(val);  break;
    case PROP_SIGNALOPERATION: res = signalOperation2str(val);  break;
    case PROP_GEOMETRY:        res = imageGeometry2str(val);    break;
    case PROP_EQUIVCLASS:      res = "";  break; // no sense printing as any value would be valid
                               
    case PROP_OPCODE:          res = opcode2str(val); break;
                           
    case PROP_D0:
    case PROP_D1:

    case PROP_S0:
    case PROP_S1:
    case PROP_S2:
    case PROP_S3:
    case PROP_S4:              res = operand2str(val); break;

    case PROP_TYPESIZE:  // A special case
    case PROP_STYPESIZE: // A special case
    case PROP_OPERAND:
    default:
        assert(false);
        break;
    }

    assert(res);
    return res;
}

unsigned PropValidator::getOperandIdx(unsigned prop)
{
    switch(prop)
    {
    case PROP_D0: return 0;
    case PROP_D1: return 1;

    case PROP_S0: return 0;
    case PROP_S1: return 1;
    case PROP_S2: return 2;
    case PROP_S3: return 3;
    case PROP_S4: return 4;

    default:
        return (unsigned)-1;
    }
}

unsigned PropValidator::attr2type(Inst inst, unsigned idx, unsigned attr)
{
    using namespace Brig;
    assert(idx < 5);

    switch(attr)
    {
    case OPERAND_ATTR_DTYPE:    return inst.type();
    case OPERAND_ATTR_STYPE:    
    case OPERAND_ATTR_CTYPE:    return getSrcType(inst);
    case OPERAND_ATTR_ITYPE:    return getImgType(inst);

    case OPERAND_ATTR_B1:       return BRIG_TYPE_B1;
    case OPERAND_ATTR_B32:      return BRIG_TYPE_B32;
    case OPERAND_ATTR_B64:      return BRIG_TYPE_B64;
    case OPERAND_ATTR_U32:      return BRIG_TYPE_U32;
    case OPERAND_ATTR_U64:      return BRIG_TYPE_U64;
    case OPERAND_ATTR_S32:      return BRIG_TYPE_S32;
    case OPERAND_ATTR_S64:      return BRIG_TYPE_S64;
    case OPERAND_ATTR_SAMP:     return BRIG_TYPE_SAMP;
    case OPERAND_ATTR_SIG32:    return BRIG_TYPE_SIG32;
    case OPERAND_ATTR_SIG64:    return BRIG_TYPE_SIG64;
    case OPERAND_ATTR_P2U:      return convPackedType2U(inst.type());

    default:
        assert(false);
        return BRIG_TYPE_NONE;
    }
}

string PropValidator::prop2str(unsigned prop) //F reuse prop2key where possible
{
    switch(prop)
    {
    case PROP_OPCODE:          return "opcode";
    case PROP_TYPE:            return "type";
    case PROP_SOURCETYPE:      return "src type";
    case PROP_IMAGETYPE:       return "image type";
    case PROP_COORDTYPE:       return "coord type";
    case PROP_SIGNALTYPE:      return "signal type";
                               
    case PROP_PACK:            return "packing";
    case PROP_COMPARE:         return "comparison operator";
    case PROP_ROUND:           return "rounding";
    case PROP_FTZ:             return "modifier";
    case PROP_ISCONST:         return "modifier";
    case PROP_ISNONULL:        return "modifier";
    case PROP_ALIGN:           return "align";
    case PROP_ATOMICOPERATION: return "atomic operation";
    case PROP_SIGNALOPERATION: return "signal operation";
    case PROP_MEMORYORDER:     return "memory order";
    case PROP_MEMORYSCOPE:     return "memory scope";
    case PROP_SEGMENTS:        return "fence segment";
    case PROP_GEOMETRY:        return "geom";
    case PROP_SEGMENT:         return "storage class";
    case PROP_WIDTH:           return "width";
    case PROP_EQUIVCLASS:      return "equivalence class";
                               
    case PROP_D0:              return "operand 0";
    case PROP_D1:              return "operand 1";
                               
    case PROP_S0:              return "operand 0";
    case PROP_S1:              return "operand 1";
    case PROP_S2:              return "operand 2";
    case PROP_S3:              return "operand 3";
    case PROP_S4:              return "operand 4";

    case PROP_TYPESIZE:  // A special case
    case PROP_STYPESIZE: // A special case
    case PROP_OPERAND:
    default:
        assert(false);
        return "";
    }
}

const char* PropValidator::prop2key(unsigned prop)
{
    switch(prop)
    {
    case PROP_FTZ:         return "modifier";      ///F
    case PROP_ISCONST:     return "modifier";      ///F
    case PROP_ISNONULL:    return "modifier";      ///F
    case PROP_SEGMENTS:    return "fenceSegment";  ///F
                           
    case PROP_D0:          return "operand 0";
    case PROP_D1:          return "operand 1";
                           
    case PROP_S0:          return "operand 0";
    case PROP_S1:          return "operand 1";
    case PROP_S2:          return "operand 2";
    case PROP_S3:          return "operand 3";
    case PROP_S4:          return "operand 4";

    case PROP_TYPESIZE:  // A special case
    case PROP_STYPESIZE: // A special case
    case PROP_OPERAND:
        assert(false); 
        return "";

    default: return getBrigPropName(prop);
    }
};

void PropValidator::invalidFormat(Inst inst, const char* msg)
{
    validate(inst, false, "Invalid instruction format, expected " + string(msg));
}

void PropValidator::brigPropError(Inst inst, unsigned prop, unsigned value, unsigned* vals, unsigned length)
{
    propError(inst, prop, val2str(prop, value), vals, length);
}

void PropValidator::propError(Inst inst, unsigned prop, string value, unsigned* vals, unsigned length)
{
    assert(inst);
    assert(vals && length > 0);
    assert(PROP_MINID < prop && prop < PROP_MAXID);
    assert(prop != PROP_TYPESIZE && prop != PROP_STYPESIZE); // metaproperties are special

    string s = val2str(prop, vals[0]);
    for (unsigned i = 1; i < length; ++i) s = s + ", " + val2str(prop, vals[i]);

    unsigned operandIdx = getOperandIdx(prop);
    string expected = (length == 1)? ", expected: " : ", expected one of: ";
    if (operandIdx <= 4)
    {
        if (!inst.operand(operandIdx))
        {
            validate(inst, operandIdx, false, "Missing " + prop2str(prop) + expected + s);
        }
        else
        {
            validate(inst, operandIdx, false, "Invalid " + prop2str(prop) + expected + s);
        }
    }
    else
    {
        if (value.length() > 0) value = " (" + value + ")";
        validate(inst, false, "Instruction has invalid " + prop2str(prop) + value + expected + s);
    }
}

bool PropValidator::validateTypeSz(Inst inst, unsigned propVal, unsigned type, const char* typeName, bool isAssert /*=true*/)
{
    assert(inst);

    switch (propVal)
    {
    case TYPESIZE_VAL_SEG:
        if (getTypeSize(type) == getSegAddrSize(HSAIL_ASM::getSegment(inst), isLargeModel())) return true;
#if !ENABLE_ADDRESS_SIZE_CHECK
        // This is a temporary workaround for lowering
        if (isLargeModel() && getSegAddrSize(HSAIL_ASM::getSegment(inst), isLargeModel()) == 32 && getTypeSize(type) == 64) return true;
#endif
        if (isAssert) validate(inst, false, string(typeName) + " must match segment kind and machine model");
        break;

    case TYPESIZE_VAL_MODEL:
        return validateInstTypeSize(inst, type, typeName, isAssert);

    case TYPESIZE_VAL_SIGNAL:
        if (type == Brig::BRIG_TYPE_SIG64 && isLargeModel())  return true;
        if (type == Brig::BRIG_TYPE_SIG32 && !isLargeModel()) return true;
        if (isAssert) validate(inst, false, "Instruction type must match machine model");
        break;

    case TYPESIZE_VAL_ATOMIC:
        return validateAtomicTypeSize(inst, isAssert);

    default:
        assert(false);
        break;
    }
    return false;
}

bool PropValidator::validateTypesize(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(length == 1);
    assert(attr == TYPESIZE_ATTR_NONE);

    return validateTypeSz(inst, vals[0], inst.type(), "Instruction type", isAssert);
}

bool PropValidator::validateStypesize(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(length == 1);
    assert(attr == STYPESIZE_ATTR_NONE);

    return validateTypeSz(inst, vals[0], getSrcType(inst), "Source type", isAssert);
}

bool PropValidator::validateOperandAttr(Inst inst, unsigned operandIdx, unsigned attr, bool isDst, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);
    assert(ATTR_MINID < attr && attr < ATTR_MAXID);
    assert(inst.operand(operandIdx));

    switch (attr)
    {
    case OPERAND_ATTR_DTYPE:
    case OPERAND_ATTR_STYPE:
    case OPERAND_ATTR_CTYPE:
    case OPERAND_ATTR_B1:   
    case OPERAND_ATTR_B32:  
    case OPERAND_ATTR_B64:  
    case OPERAND_ATTR_U32:  
    case OPERAND_ATTR_U64:  
    case OPERAND_ATTR_S32:  
    case OPERAND_ATTR_S64:  
    case OPERAND_ATTR_SAMP: 
    case OPERAND_ATTR_SIG32:
    case OPERAND_ATTR_SIG64:
    case OPERAND_ATTR_ITYPE:
    case OPERAND_ATTR_P2U:    return validateOperandType(inst, operandIdx, isDst, attr, isAssert);

    case OPERAND_ATTR_MODEL:  return validateOperandTypeSize(inst, operandIdx, isAssert);
    case OPERAND_ATTR_SEG:    return checkAddrSeg(inst, operandIdx, isAssert);
    case OPERAND_ATTR_TSEG:   return checkAddrTSeg(inst, operandIdx, isAssert);

    default:
        assert(false);
        return false;
    }
}

// 1) address size must match _instruction_ segment size;
// 2) if inst.segment=flat, address must be flat
// 3) if address includes a symbol, symbol.segment must be the same as instr.segment
bool PropValidator::checkAddrSeg(Inst inst, unsigned operandIdx, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);

    OperandAddress opr = inst.operand(operandIdx);
    assert(opr);

    if (HSAIL_ASM::getSegment(inst) == Brig::BRIG_SEGMENT_FLAT && opr.symbol())
    {
        if (isAssert) validate(inst, operandIdx, false, "Address segment does not match instruction segment (expected flat address)");
        return false;
    }
    if (opr.symbol() && opr.symbol().segment() != HSAIL_ASM::getSegment(inst))
    {
        if (isAssert) validate(inst, operandIdx, false, "Address segment does not match instruction segment");
        return false;
    }

    unsigned addrSize = getAddrSize(opr, isLargeModel()); // 32 or 64; 0 if both are valid
    if (addrSize != 0 && addrSize != getSegAddrSize(HSAIL_ASM::getSegment(inst), isLargeModel()))
    {
#if !ENABLE_ADDRESS_SIZE_CHECK
        // This is a temporary workaround for lowering
        if (isLargeModel() && getSegAddrSize(HSAIL_ASM::getSegment(inst), isLargeModel()) == 32 && addrSize == 64) return true;
#endif
        if (isAssert) validate(inst, operandIdx, false, "Address size does not match instruction type");
        return false;
    }
    return true;
}

// 4) opaque symbols used in address must match instruction type (rwimg, roimg, samp)
bool PropValidator::checkAddrTSeg(Inst inst, unsigned operandIdx, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);

    OperandAddress opr = inst.operand(operandIdx);
    assert(opr);

    if (!checkAddrSeg(inst, operandIdx, isAssert)) return false;
    if (!opr.symbol()) return true;

    using namespace Brig;
    unsigned type = inst.type();
    unsigned otype = opr.symbol().type();

    if (type == otype) return true;

    if (isOpaqueType(type))
    {
        if (isAssert) validate(inst, operandIdx, false, "Instruction type does not match address symbol type");
        return false;
    }

    if (isOpaqueType(otype))
    {
        if (isAssert) validate(inst, operandIdx, false, "Opaque symbol used in address does not match instruction type");
        return false;
    }

    return true;
}

bool PropValidator::isImmInRange(OperandImmed imm, unsigned low, unsigned high)
{
    if (getImmSize(imm) != 32) return false;
    unsigned val = *reinterpret_cast<const uint32_t*>(&imm.brig()->bytes[0]);
    return low <= val && val <= high;
}

bool PropValidator::checkOperandKind(Inst inst, unsigned operandIdx, unsigned* vals, unsigned length, bool isAssert)
{
    assert(inst);
    assert(operandIdx <= 4);
    assert(vals && length > 0);

    using namespace Brig;

    Operand opr = inst.operand(operandIdx);
    unsigned kind = opr? opr.kind() : (unsigned)-1;

    for (unsigned i = 0; i < length; ++i)
    {
        switch(vals[i])
        {
        case OPERAND_VAL_NULL:      if (!opr) return true; break;

        case OPERAND_VAL_ADDR:      if (kind == BRIG_OPERAND_ADDRESS)                                                 return true; break;
        case OPERAND_VAL_LAB:       if (kind == BRIG_OPERAND_LABEL_REF && DirectiveLabel(OperandLabelRef(opr).ref()))             return true; break;
        case OPERAND_VAL_FUNC:      if (kind == BRIG_OPERAND_FUNCTION_REF)  return true; break;
        case OPERAND_VAL_ARGLIST:   if (kind == BRIG_OPERAND_ARGUMENT_LIST) return true; break;
        case OPERAND_VAL_JUMPTAB:   if (isJumpTab(inst, operandIdx, isAssert)) return true; break;
        case OPERAND_VAL_CALLTAB:   if (isCallTab(inst, operandIdx, isAssert)) return true; break;
        case OPERAND_VAL_FBARRIER:  if (kind == BRIG_OPERAND_FBARRIER_REF)  return true; break;

        case OPERAND_VAL_ROIMAGE:   if (isImage(opr, false)) return true; break;
        case OPERAND_VAL_RWIMAGE:   if (isImage(opr, true))  return true; break;
        case OPERAND_VAL_SAMPLER:   if (isSampler(opr))      return true; break;

        case OPERAND_VAL_IMM:       if (kind == BRIG_OPERAND_IMMED || kind == BRIG_OPERAND_WAVESIZE) return true; break;
        case OPERAND_VAL_IMM0T2:    if (kind == BRIG_OPERAND_IMMED && isImmInRange(opr, 0, 2))       return true; break;
        case OPERAND_VAL_IMM0T3:    if (kind == BRIG_OPERAND_IMMED && isImmInRange(opr, 0, 3))       return true; break;

        case OPERAND_VAL_REG:       if (kind == BRIG_OPERAND_REG)   return true; break;
        case OPERAND_VAL_REG_V2:    if (kind == BRIG_OPERAND_REG_VECTOR && OperandRegVector(opr).regCount() == 2) return true; break;
        case OPERAND_VAL_REG_V3:    if (kind == BRIG_OPERAND_REG_VECTOR && OperandRegVector(opr).regCount() == 3) return true; break;
        case OPERAND_VAL_REG_V4:    if (kind == BRIG_OPERAND_REG_VECTOR && OperandRegVector(opr).regCount() == 4) return true; break;

        default:
            assert(false);
            break;
        }
    }

    return false;
}

bool PropValidator::validateOperand(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(inst);
    assert(vals && length > 0);
    assert(PROP_MINID < prop && prop < PROP_MAXID);
    assert(ATTR_MINID < attr && attr < ATTR_MAXID);

    bool isDst = (prop == PROP_D0 || prop == PROP_D1);
    unsigned operandIdx = getOperandIdx(prop);
    assert(operandIdx <= 4);

    bool res = checkOperandKind(inst, operandIdx, vals, length, isAssert);

    if (!res)
    {
        if (isAssert) propError(inst, prop, "", vals, length); // FIXME: decode 'val'
        return res;
    }

    res = !isDst || validateDstVector(inst.operand(operandIdx));
    if (isAssert && !res) validate(inst, operandIdx, res, "Destination vector operand must not include the same register more than once");
    if (!res) return res;

    if (attr != OPERAND_ATTR_NONE)
    {
        return validateOperandAttr(inst, operandIdx, attr, isDst, isAssert);
    }
    return true;
}

bool PropValidator::validateEqclass(Inst inst, unsigned prop, unsigned attr, unsigned* vals, unsigned length, bool isAssert /*=true*/)
{
    assert(prop == PROP_EQUIVCLASS);
    assert(attr == EQCLASS_ATTR_NONE);
    assert(length == 1);

    if (vals[0] == EQCLASS_VAL_ANY) 
    {
        return true;
    }
    else if (vals[0] == EQCLASS_VAL_0) 
    {
        if (getEqClass(inst) == 0) return true;
        if (isAssert) 
        {
            ostringstream s;
            s << "Instruction has invalid equivClass " << getEqClass(inst) << ", expected: 0";
            validate(inst, false, s.str());
        }
        return false;
    }
    else
    {
        assert(false);
        return false;
    }

}

void PropValidator::invalidVariant(Inst inst, unsigned prop) 
{
    validate(inst, false, "Instruction has invalid " + prop2str(prop));
}

void PropValidator::invalidVariant(Inst inst, unsigned prop1, unsigned prop2) 
{
    validate(inst, false, "Instruction has invalid combination of " + prop2str(prop1) + " and " + prop2str(prop2));
}

//-----------------------------------------------------------------------------

static string getOperandTypeName(unsigned attr)
{
    switch(attr)
    {
    case OPERAND_ATTR_DTYPE:    return "operation";
    case OPERAND_ATTR_STYPE:    return "source";
    case OPERAND_ATTR_CTYPE:    return "coord";
    default:                    return ""; // operand has fixed type
    }
}

static string getExpectedTypeName(unsigned type)
{
    return " (" + string(typeX2str(type)) + ")";
}

string PropValidator::getErrHeader(unsigned oprIdx, const char* oprPref) 
{ 
    assert(oprIdx <= 4);
    return string(oprPref) + " " + static_cast<char>('0' + oprIdx);
}

void PropValidator::wavesizeError(Inst inst, unsigned oprIdx, unsigned type, unsigned attr)
{
    assert(oprIdx <= 4);

    string typeInfo = getOperandTypeName(attr);
    typeInfo += typeInfo.empty()? ("expected operand type" + getExpectedTypeName(type)) : " type";
    operandError(inst, oprIdx, "cannot be wavesize: incompatible with ", typeInfo);
}

void PropValidator::operandError(Inst inst, unsigned oprIdx, string msg1, string msg2 /*=""*/)
{
    assert(oprIdx <= 4);

    string errHdr = getErrHeader(oprIdx, "Operand");
    validate(inst, oprIdx, false, errHdr + " " + msg1 + msg2);
}

void PropValidator::operandTypeError(Inst inst, unsigned oprIdx, unsigned type)
{
    assert(oprIdx <= 4);

    string errHdr = getErrHeader(oprIdx, "Invalid operand");
    validate(inst, oprIdx, false, errHdr + " type: expected " + typeX2str(type));
}

//F: change ITYPE handling to match STYPE, etc?
void PropValidator::operandSizeError(Inst inst, unsigned oprIdx, unsigned type, unsigned attr)
{
    assert(inst);
    assert(oprIdx <= 4);

    string err = getOperandTypeName(attr);
    if (!err.empty())
    {
        operandError(inst, oprIdx, "size does not match ", err + ((attr == OPERAND_ATTR_DTYPE)? " size" : " type size"));
        return;
    }

    Operand opr = inst.operand(oprIdx);
    string errHdr = getErrHeader(oprIdx, "Invalid operand");

    const char* errMsg = "";
    if (OperandImmed(opr)) 
    {
        switch(getTypeSize(type))
        {
        case 1:   errMsg = "an 1-bit immediate";  break;
        case 32:  errMsg = "a 32-bit immediate";  break;
        case 64:  errMsg = "a 64-bit immediate";  break;
        case 128: errMsg = "a 128-bit immediate"; break;
        }
    } 
    else if (OperandReg(opr) || OperandRegVector(opr)) 
    {
        switch(getTypeSize(type))
        {
        case 1:   errMsg = "a 'c' register";  break;
        case 32:  errMsg = "an 's' register"; break;
        case 64:  errMsg = "a 'd' register";  break;
        case 128: errMsg = "a 'q' register";  break;
        }
    }
    else
    {
        assert(false);
    }

    validate(inst, oprIdx, false, errHdr + " size: expected " + errMsg);
}

bool PropValidator::validateOperandType(Inst inst, unsigned oprIdx, bool isDst, unsigned attr, bool isAssert)
{
    assert(inst);
    assert(oprIdx <= 4);
    using namespace Brig;

    Operand opr   = inst.operand(oprIdx);
    unsigned type = attr2type(inst, oprIdx, attr);

    if (!opr) 
    {
        if (isAssert) operandError(inst, oprIdx, "is missing");
        return false;
    }

    if (isDst && !OperandReg(opr) && !OperandRegVector(opr))
    {
        if (isAssert) operandError(inst, oprIdx, "must be a register or a vector");
        return false;
    }

    if (OperandWavesize(opr) && !isIntType(type)) 
    {
        if (isAssert) wavesizeError(inst, oprIdx, type, attr);
        return false;
    }

    //F Remove as soon as possible - we won't need this block of code in the near future.
    //F This code is as a temporary patch that allows using images and samplers with image-handling instructions.
    //F In the future we do not need these checks as all relevant cases should be handled via addr.tseg
    if (isOpaqueType(type))
    {
        OperandAddress addr = opr;
        if (addr) 
        {
            DirectiveVariable var = addr.symbol();
            if (var && var.type() == type) return true;
            if (isAssert) operandTypeError(inst, oprIdx, type);
            return false;
        } 
        else if (!OperandReg(opr)) // NB: regs are handled below
        {
            if (isAssert) operandError(inst, oprIdx, "must be a register or an opaque object ", getExpectedTypeName(type));
            return false;
        }
    }

    unsigned iSize = getTypeSize(type);
    bool isSubWord = (iSize == 8) || (iSize == 16);
    
    if (OperandReg(opr) || OperandRegVector(opr))
    {
        unsigned oSize = getRegSize(opr);
        if (iSize == oSize || (isSubWord && oSize == 32)) return true;
        if (isAssert) operandSizeError(inst, oprIdx, type, attr);
        return false;
    }
    else if (OperandImmed(opr))
    {
        unsigned oSize = getImmSize(opr);
        if (iSize == oSize) return true;
        if (iSize == 1 && oSize == 8)
        {
            if (isImmB1(opr)) return true;
            if (isAssert) operandError(inst, oprIdx, "must be either 0 or 1 (expected b1 type)");
            return false;
        }
        if (isAssert) operandSizeError(inst, oprIdx, type, attr);
        return false;
    }
    else
    {
        return true; // nothing to check
    }
}

bool PropValidator::validateDstVector(OperandRegVector vector)
{
    if (!vector) return true;

    assert(2 <= vector.regCount() && vector.regCount() <= 4);

    // Check that all registers in destination vector are unique
    for (unsigned i = 0, c = vector.regCount(); i < c; ++i) 
    {
        SRef name1 = vector.regs(i);
        for (unsigned j = i + 1; j < c; ++j) 
        {
            SRef name2 = vector.regs(j);
            if (name1 == name2) return false; //F: replace with offset check
        }        
    }
    return true;
}

bool PropValidator::validateAtomicTypeSize(Inst inst, bool isAssert)
{
    assert(inst);

    if (getTypeSize(inst.type()) == 64 && !isLargeModel())
    {
        if (isAssert) validate(inst, -1, false, "Instruction type size 64 is not allowed with small machine model");
        return false;
    }
    return true;
}

bool PropValidator::validateInstTypeSize(Inst inst, unsigned type, const char* typeName, bool isAssert)
{
    assert(inst);

    unsigned typeSize = getMachineSize();

    if (getTypeSize(type) != typeSize)
    {
        if (isAssert) validate(inst, -1, false, string(typeName) + " size must match machine model");
        return false;
    }
    return true;
}

bool PropValidator::validateOperandTypeSize(Inst inst, unsigned oprIdx, bool isAssert)
{
    assert(inst);
    assert(oprIdx <= 4);

    Operand opr = inst.operand(oprIdx);
    if (!opr) 
    {
        if (isAssert) operandError(inst, oprIdx, " is missing");
        return false;
    }

    if (OperandReg(opr))
    {
        if (getRegSize(opr) == getMachineSize()) return true;
        if (isAssert) operandError(inst, oprIdx, "size must match machine model");
        return false;
    }
    
    assert(OperandLabelRef(opr) || OperandFunctionRef(opr));
    return true;
}

//-----------------------------------------------------------------------------

} // namespace HSAIL_ASM
