version 0:96:$full:$large;

function &TestFunc12a(arg_b32 %out_arg0)(arg_s32 %in_arg0, arg_u32 %in_arg1)
{
	ret;
};

static function &TestFunc12b(arg_b32 %out_arg0)(arg_s32 %in_arg0, align 4 arg_u32 %in_arg1);

signature &TestFuncSign12(arg_b32)(arg_s32, arg_u32);
signature &TestFuncSign02()(arg_s32, arg_u32);
signature &TestFuncSign10(arg_b32)();
signature &TestFuncSign00()();

function &TestCalls()(arg_u32 %in_arg0)
{
	ldc_u64 $d1, &TestFunc12a;

	{
		arg_b32 %oarg0;
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];
		call  $d1 (%oarg0) (%iarg0, %iarg1) [&TestFunc12a];
	}       		
	{
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];
		call   $d1 () (%iarg0, %iarg1) [&TestFunc12a]; // Output args are optional
	}       		
	{
		arg_b32 %oarg0;
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];

		call   $d1 (%oarg0) (%iarg0, %iarg1) [&TestFunc12a, &TestFunc12b];
	}       		
	{
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];

		call   $d1 () (%iarg0, %iarg1) [&TestFunc12a, &TestFunc12b];  // Output args are optional
	}       		
	{
		arg_b32 %oarg0;
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];

		call   $d1 (%oarg0) (%iarg0, %iarg1) &TestFuncSign12;
	}       		
	{
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];

		call   $d1 () (%iarg0, %iarg1) &TestFuncSign12;   // Output args are optional
	}       		
	{
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];

		call   $d1 () (%iarg0, %iarg1) &TestFuncSign02;
	}       		
	{
		arg_s32 %iarg0;
		arg_u32 %iarg1;

		st_arg_s32	0, [%iarg0];
		st_arg_u32	0, [%iarg1];

		call   $d1 (%iarg0, %iarg1) &TestFuncSign02;
	}       		
	{
		arg_b32 %oarg0;

		call   $d1 (%oarg0) () &TestFuncSign10;
	}       		
	{
		call   $d1 () () &TestFuncSign00;
	}       		
	{
		call   $d1 () &TestFuncSign00;
	}       		
	{
		call   $d1 () &TestFuncSign00;
	}       		

	ret;
};

static function &TestFunc12b(arg_b32 %out_arg0)(arg_s32 %in_arg0, arg_u32 %in_arg1)
{
	ret;
};

//==================================================================
// Return arguments are optional

signature &TestSignatureNoRet()();

function &TestCallsNoRet()(arg_b64 %addr0, arg_b64 %addr1, arg_b64 %addr2)
{
	ld_arg_u64 $d1, [%addr0];
	{
		call   $d1 () () &TestSignatureNoRet; // Return arguments are optional
	}       		
};

//==================================================================
// Call Targets may not be defined, only declared. It is ok

function &TestFuncX    ()(arg_s32 %in_arg0) { ret; };
function &TestFuncUndef()(arg_s32 %in_arg0); // defined elsewhere

function &TestCallUndefTarget()(arg_u32 %in_arg0)
{
	ldc_u64 $d1, &TestFuncX;

	{
		arg_s32 %arg0;

		st_arg_s32	0, [%arg0];
		call   $d1 () (%arg0) [&TestFuncX, &TestFuncUndef];
	}       		
};

